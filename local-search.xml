<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>算法练习：统计好数字的数目（快速幂）</title>
    <link href="/2022/05/13/fastMi/"/>
    <url>/2022/05/13/fastMi/</url>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>又是在力扣被题折磨的一次，反反复复地提交，反反复复的不通过，不过还好了解到了快速幂的思想，这种方式能大幅提高程序的运行速度。</p><blockquote><p>题目：我们称一个数字字符串是 好数字 当它满足（下标从 0  开始）偶数 下标处的数字为 偶数   且 奇数   下标处的数字为 质数  （2，3，5  或  7）。</p></blockquote><ul><li>比方说，”2582”  是好数字，因为偶数下标处的数字（2  和  8）是偶数且奇数下标处的数字（5 和  2）为质数。但  “3245”  不是 好数字，因为  3  在偶数下标处但不是偶数。<br>给你一个整数  n ，请你返回长度为  n  且为好数字的数字字符串   总数  。由于答案可能会很大，请你将它对  109 + 7  取余后返回  。</li></ul><p>一个 数字字符串   是每一位都由  0  到 9  组成的字符串，且可能包含前导 0.<a href="https://leetcode.cn/problems/count-good-numbers/">(题目来源：LeetCode）</a></p><h2 id="二-分析"><a href="#二-分析" class="headerlink" title="二.分析"></a>二.分析</h2><p>这道题乍一看似乎挺简单，由于是让我们返回好数字的个数，对于偶数下标来说符合条件的无非就 0,2,4,6,8 这几个数字，而奇数下标只有 1,3,5,7 这四个数字。我们只需要计算每一位上符合条件的数字的个数之积，顶多再模上 1000000007 就是最终答案了。但是真的是这样的吗？</p><ul><li>敲完代码直接提交（自信加蔑视）</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">countGoodNumbers</span><span class="hljs-params">(<span class="hljs-type">long</span> n)</span> </span>&#123;<br>        <span class="hljs-type">double</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            result = (Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">4</span>,n/<span class="hljs-number">2</span>) * Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">5</span>,n/<span class="hljs-number">2</span>)) % <span class="hljs-number">1000000007</span>;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            result = (Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">4</span>,n/<span class="hljs-number">2</span>) * Math.<span class="hljs-built_in">pow</span>(<span class="hljs-number">5</span>,n/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>)) % <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>) result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>心想这不就完了吗，很难吗？但是最终结果就是它死活不让我过，卡在了 50：<br><img src="https://s3.bmp.ovh/imgs/2022/05/12/9cda7a82442d9a34.webp" alt="迷茫啊..."><br>我***，这哪有什么问题，这都不让过？离谱啊…… 思考一番无果我只能去翻翻源码，这一下又让我有了新的收获：<br><img src="https://s3.bmp.ovh/imgs/2022/05/12/7c450cf14f75d653.webp"><br>它是一个本地方法，也就是由 c&#x2F;c++编写的方法，java 能拿来用，而这个 pow 方法返回四舍五入到最接近的 int 值的参数值，而 int 最多只能表示 2147483647（2 的 31 次方-1），但是代码里面的 5 的 50 次方早就超过了其最大值，因此这里已经溢出，错误也就随之产生了。</p><p>行，那我就换个方法，不用这个 pow 方法，我自己写一个能得到指数值的方法不就好了吗？</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 说明：这里举个例子，想简单告诉一下大家这种循环计算时会非常耗时间</span><br><span class="hljs-comment"> */</span><br><br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">long</span> <span class="hljs-title">normalCal</span>(<span class="hljs-params"><span class="hljs-built_in">int</span> power, <span class="hljs-built_in">int</span> <span class="hljs-keyword">base</span></span>)</span> &#123;<br>        <span class="hljs-built_in">long</span> result = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; power; i++) &#123;<br>            result = result * <span class="hljs-keyword">base</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        <span class="hljs-built_in">long</span> result = normalCal(<span class="hljs-number">30</span>,<span class="hljs-number">5</span> );<br><br>        System.<span class="hljs-keyword">out</span>.println(result);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们求的是 5 的 30 次方，那么就会执行 30 次循环。不难发现其时间复杂度为 O(N),其中 N 为指数。在我们这段代码中还好，要是我换成 5 的 100 次方呢？那么会有以下两个问题：</p><ul><li>1.假如真的是 5 的 200 次方，即使我们用 long 接收，结果也会溢出的，这又会回到前面的问题上去。</li><li>2.就算我们想尽办法正确得到了这个结果，但这会花费大量的时间，这样提交上去肯定会超时，最终也会不成功。<br>那么是否有一种二者问题都解决掉的方案呢？答案肯定是有的，这就是之前我们将要说到的快速幂思想。</li></ul><h2 id="三-快速幂思想"><a href="#三-快速幂思想" class="headerlink" title="三.快速幂思想"></a>三.快速幂思想</h2><p><em>我们先来初步认识下快速幂，给定一个 2 的 12 次方式子让你计算，你拿到这个题后会怎么想呢？</em></p><ul><li>为了计算的简便，我们通常可以将 2 的 12 次方转换为 4 的 6 次方进而转成 16 的 4 次方…进行计算。</li></ul><hr><p>1.快速幂正好是这种思想，在计算机中 2 的 12 次方要循环 12 次，而我们通过将指数减半，底数平方的思想可以减少循环的次数，从而提高性能。就比如上述的 2 的 12 次方：我们通过快速幂的思想思考它是这样的：2 的 12 次方 -&gt; 4 的 6 次方 -&gt; 16 的 3 次方 -&gt; 256 的 1 次方 乘以 16。前者循环了 12 次，而后者只需要循环 4 次，要是有更高指数计算，则能节省循环的次数也就不言而喻了。</p><p>那我们怎么解决因为计算出的值过大而溢出导致出错的问题呢？我们先来了解一下模的运算规律吧：<br><code>a). (a+b)%p=(a%p+b%p)%p</code><br><code>b). (a-b)%p=(a%p-b%p)%p</code><br><code>c). (a*b)%p=(a%p * b%p)%p</code> 2.在这里只需要用到第三条结论，我们可以在计算过程中就开始不断取模，而不是等到最终结果出来之后再模运算，这样就能避免最终答案太大导致出错的问题了。</p><p>因此在进行幂运算时我们可以这样做：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> <span class="hljs-title">myAns</span>(<span class="hljs-params">lon <span class="hljs-keyword">base</span>, <span class="hljs-built_in">long</span> index</span>)</span> &#123;<br>    <span class="hljs-built_in">int</span> k = <span class="hljs-number">1000000007</span>;<br>    <span class="hljs-built_in">long</span> result = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (index &gt; <span class="hljs-number">0</span>) &#123;<span class="hljs-comment">//当指数减到1时跳出循环</span><br>        <span class="hljs-keyword">if</span> (index % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">//奇数往这儿走，由于这里是奇数，指数减半会有余数，因此我们只需多乘以一个原来的result就行了</span><br>            index = index - <span class="hljs-number">1</span>;<br>            result = result * <span class="hljs-keyword">base</span> % k;<span class="hljs-comment">//乘上原来的底数</span><br>            <span class="hljs-keyword">base</span> = <span class="hljs-keyword">base</span> * <span class="hljs-keyword">base</span> % k;<span class="hljs-comment">//底数平方</span><br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//偶数来这里，这里就是正常的指数减半，底数平方</span><br>            index = index / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">base</span> = (<span class="hljs-keyword">base</span> * <span class="hljs-keyword">base</span>) % k;<br>        &#125;<br>    <span class="hljs-comment">//我们可以看到这种方式节约的循环次数是指数级的</span><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>其实上面这个代码还能更精简一些，我们还能对它进行优化。<br>我们来看看整道题的全部代码：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> &#123;<br>    <span class="hljs-comment">//优化后的代码，这个方法就是进行幂运算</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">long</span> <span class="hljs-title">findMyResult</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> <span class="hljs-keyword">base</span>, <span class="hljs-built_in">long</span> index</span>)</span> &#123;<br>        <span class="hljs-built_in">long</span> result = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(index&gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(power % <span class="hljs-number">2</span> == <span class="hljs-number">1</span>)&#123;<br>                result = result * <span class="hljs-keyword">base</span> % <span class="hljs-number">1000000007</span>;<br>            &#125;<br>            index = index / <span class="hljs-number">2</span>;<span class="hljs-comment">//奇数除以2会舍去小数点后面的数，能自动实现减1操作</span><br>            <span class="hljs-keyword">base</span> = <span class="hljs-keyword">base</span> * <span class="hljs-keyword">base</span> % <span class="hljs-number">1000000007</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-title">countGoodNumbers</span>(<span class="hljs-params"><span class="hljs-built_in">long</span> n</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span>(n % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-built_in">long</span> result =  findMyResult(<span class="hljs-number">4</span>,n/<span class="hljs-number">2</span>) % <span class="hljs-number">1000000007</span>;<br>            result = (result * findMyResult(<span class="hljs-number">5</span>,n/<span class="hljs-number">2</span>)) % <span class="hljs-number">1000000007</span>;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>) result;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-built_in">long</span> result = (findMyResult(<span class="hljs-number">4</span>,n/<span class="hljs-number">2</span>) % <span class="hljs-number">1000000007</span>);<br>            result = (result * findMyResult(<span class="hljs-number">5</span>,n/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>)) %  <span class="hljs-number">1000000007</span>;<br>            <span class="hljs-keyword">return</span> (<span class="hljs-built_in">int</span>) result;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>完 ~</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>算法练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello Hexo！一款高效的个人博客框架</title>
    <link href="/2022/05/12/mypost/"/>
    <url>/2022/05/12/mypost/</url>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><h4 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h4><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用  <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>现在网上大多数的博客系统其实都是别人的框架，比较流行的框架有 WordPress， halo ， hugo 还有我们今天要讲的 Hexo。</p><h2 id="二-安装准备"><a href="#二-安装准备" class="headerlink" title="二.安装准备"></a>二.安装准备</h2><ul><li>本文部分代码可能失效，具体以<a href="https://hexo.io/zh-cn/docs/">官网 | Hexo</a>为准<br>由于 Hexo 是基于 Node.js 的，因此我们需要先下载 Node.js，另外只需要安装 git 工具就 ok 了。</li></ul><h4 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装<a href="https://nodejs.org/en/">Node.js</a></h4><p>傻瓜式安装，一直 next 即可。如有疑惑请自行上网搜索，网上安装教程很全，相信大家不会在这耽搁太多时间。安装完成后我们任意位置单击鼠标右键会有一个 Git Bash Here，点击后就会弹出 git 命令框了。<br><em>注意：若想要后面下载速度更快，请打开 git 输入以下命令</em></p><figure class="highlight routeros"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs routeros">npm<span class="hljs-built_in"> config </span><span class="hljs-built_in">set</span> registry <span class="hljs-string">&quot;https://registry.npm.taobao.org&quot;</span><br></code></pre></td></tr></table></figure><h4 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git "></a>2.安装<a href="https://git-scm.com/">Git </a></h4><p>上同。</p><h2 id="三-Hexo-安装"><a href="#三-Hexo-安装" class="headerlink" title="三.Hexo 安装"></a>三.Hexo 安装</h2><p>完成上述操作后即可开始安装 Hexo。我们通过 npm 来安装 hexo。桌面鼠标单机右键，打开 Git Bash Here。</p><ul><li>键入以下命令：</li></ul><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs avrasm">$ npm install -g hexo-<span class="hljs-keyword">cli</span><br></code></pre></td></tr></table></figure><ul><li>之后在指定路径新建文件夹（英文名），右键打开 git 命令框，输入指令：</li></ul><blockquote><p>踩坑点：千万要在你刚建好的文件夹中打开 git 命令框！</p></blockquote><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp">hexo <span class="hljs-keyword">init</span><br></code></pre></td></tr></table></figure><p>到这里 Hexo 就彻底安装完毕了。我们可以看到刚刚的文件夹里面新增了很多文件以及文件夹：<br><img src="https://s3.bmp.ovh/imgs/2022/05/12/d1f38c45ad2cbd15.jpg" alt="文件夹概览"></p><h2 id="四-Hexo-使用"><a href="#四-Hexo-使用" class="headerlink" title="四.Hexo 使用"></a>四.Hexo 使用</h2><h4 id="1-自定义配置"><a href="#1-自定义配置" class="headerlink" title="1.自定义配置"></a>1.自定义配置</h4><p>打开_config.yml 进行基础配置，比如修改你的博客的名字之类的，详情见<a href="https://hexo.io/zh-cn/docs/">官网 | Hexo</a><br><img src="https://s3.bmp.ovh/imgs/2022/05/12/3696058c67c12c00.webp"></p><h4 id="2-创建文章"><a href="#2-创建文章" class="headerlink" title="2.创建文章"></a>2.创建文章</h4><p>a).先整体说一下各个文件是干嘛的</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs awk">.<br>├── _config.yml  <span class="hljs-regexp">//</span>这个是配置文件，用于修改文章数据的，点进去之后里面会有详细注解<br>├── package.json <span class="hljs-regexp">//</span>应用程序信息，依赖的模块列表<br>├── scaffolds <span class="hljs-regexp">//</span>包含三个文章模板，分别是draft，page，post。博客的定制修改会对模板进行修改。<br>├── source <span class="hljs-regexp">//</span>我们写的文章文件夹就存在这里，包括我们的 Markdown 文稿，这里面一般也可以新建一个文件夹用来放一些我们博客中需要用到的图片<br>|   ├── _drafts <span class="hljs-regexp">//</span>就是草稿<br>|   └── _posts <span class="hljs-regexp">//</span>这就是存文章的文件夹<br>└── themes <span class="hljs-regexp">//</span>用于修改Hexo主题的<br></code></pre></td></tr></table></figure><p>b).我们进入根目录，就是你刚刚新建的文件夹的名字<br><img src="https://s3.bmp.ovh/imgs/2022/05/12/7fb240132cd720cd.webp"></p><p>输入以下命令：</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gauss">$ hexo <span class="hljs-keyword">new</span> [layout] &lt;<span class="hljs-built_in">title</span>&gt;<br></code></pre></td></tr></table></figure><p>也可以不设置  <code>layout</code> ，默认使用  <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a>  中的  <code>default_layout</code>  参数代替（默认是 post）。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">$ hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;My First Post&quot;</span><br></code></pre></td></tr></table></figure><p>之后我们从根目录依次点击 source –&gt; _posts –&gt; My First Post.md 编辑文件。<br>进入之后他是长这样的：<br><img src="https://s3.bmp.ovh/imgs/2022/05/12/d1f38c45ad2cbd15.jpg"><br><code>---</code> 之间是 front-matter，是我们每篇文章的一些变量，我们可以在这里单独进行设置，也可以在_config.yml 中统一配置。而在<code>---</code>之外的地方就是我们写自己博客内容的位置了。需要注意要用 MarkDown 语法哦。<br>c).写完保存之后，在根目录再次打开 git 命令框输入</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo clean<br></code></pre></td></tr></table></figure><ul><li>每次运行前建议 clean 一下缓存，免得出现一些奇奇怪怪的问题</li></ul><p>d).输入以下命令，生成静态网页文件</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo g<br></code></pre></td></tr></table></figure><p>e).最后，输入下列代码</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$ </span>hexo s<br></code></pre></td></tr></table></figure><p>敲完回车后就在本地服务器上运行了，你的博客就可以在本地浏览了，方法：在浏览器 url 框中输入 <a href="http://localhost:4000/">http://localhost:4000</a> 即可查看。</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo安装</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>轻松理解JDBC并使用</title>
    <link href="/2022/05/08/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3JDBC%E5%B9%B6%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/05/08/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3JDBC%E5%B9%B6%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>最近学习了 JDBC，觉得非常重要，因此连忙熬夜记录下来。</p><h2 id="二-什么是-JDBC？"><a href="#二-什么是-JDBC？" class="headerlink" title="二.什么是 JDBC？"></a>二.什么是 JDBC？</h2><blockquote><p>JDBC（Java Data Base Connectivity,java 数据库连接）是一种用于执行<a href="https://so.csdn.net/so/search?q=SQL%E8%AF%AD%E5%8F%A5&spm=1001.2101.3001.7020">SQL 语句</a>的 Java API，可以为多种关系数据库提供统一访问，它由一组用 Java 语言编写的类和接口组成。</p></blockquote><p>具体来说就是 Java 为了能够让用户操作不同的数据库而编写出来的一套标准接口，我们需要调用它从而能够操作不同的数据库。而像 MySQL，SQLite，SQLService 不同的厂商为了能让 Java 操作自己家的数据库也需要实现 Java 提供的接口，这些实现了 JDBC 接口的类打成一个 jar 包，也就是我待会提到的数据库驱动。</p><h2 id="三-JDBC-的五个步骤"><a href="#三-JDBC-的五个步骤" class="headerlink" title="三.JDBC 的五个步骤"></a>三.JDBC 的五个步骤</h2><p><em>1.注册驱动</em><br><em>2.建立 Java 与数据库的联系</em><br><em>3.获得可操作的数据库对象</em><br><em>4.执行 SQL 语句</em><br><em>5.查看结果</em></p><h2 id="四-补充："><a href="#四-补充：" class="headerlink" title="四.补充："></a>四.补充：</h2><h4 id="1-connection"><a href="#1-connection" class="headerlink" title="1.connection"></a>1.connection</h4><h5 id="a-解释："><a href="#a-解释：" class="headerlink" title="a).解释："></a>a).解释：</h5><p>Connection 与特定数据库的连接（会话），在连接上下文中执行 sql 语句并返回结果。</p><h5 id="b-常用方法："><a href="#b-常用方法：" class="headerlink" title="b).常用方法："></a>b).常用方法：</h5><ul><li>createStatement()：创建向数据库发送 sql 的 statement 对象。</li><li>prepareStatement(sql) ：创建向数据库发送预编译 sql 的 PrepareSatement 对象。</li><li>prepareCall(sql)：创建执行存储过程 callableStatement 对象。</li><li>setAutoCommit(boolean autoCommit)：设置事务是否自动提交。</li><li>commit() ：在链接上提交事务。</li><li>rollback() ：在此链接上回滚事务。</li></ul><h4 id="2-statement"><a href="#2-statement" class="headerlink" title="2.statement"></a>2.statement</h4><h5 id="a-解释：-1"><a href="#a-解释：-1" class="headerlink" title="a).解释："></a>a).解释：</h5><p>用于执行静态 SQL 语句并返回它所生成结果的对象。三种 Statement 类：</p><ul><li>Statement：由 createStatement 创建，用于发送简单的 SQL 语句（不带参数）。</li><li>PreparedStatement ：继承自 Statement 接口，由 preparedStatement 创建，用于发送含有一个或多个参数的 SQL 语句。PreparedStatement 对象比 Statement 对象的效率更高，并且可以防止 SQL 注入，所以我们一般都使用 PreparedStatement。</li><li>CallableStatement：继承自 PreparedStatement 接口，由方法 prepareCall 创建，用于调用存储过程。</li></ul><h5 id="b-常用方法：-1"><a href="#b-常用方法：-1" class="headerlink" title="b).常用方法："></a>b).常用方法：</h5><ul><li>execute(String sql):运行语句，返回是否有结果集</li><li>executeQuery(String sql)：运行 select 语句，返回 ResultSet 结果集。</li><li>executeUpdate(String sql)：运行 insert&#x2F;update&#x2F;delete 操作，返回更新的行数。</li><li>addBatch(String sql) ：把多条 sql 语句放到一个批处理中。</li><li>executeBatch()：向数据库发送一批 sql 语句执行。</li></ul><h2 id="五-Java-操作数据库实战"><a href="#五-Java-操作数据库实战" class="headerlink" title="五.Java 操作数据库实战"></a>五.Java 操作数据库实战</h2><h4 id="1-注册驱动"><a href="#1-注册驱动" class="headerlink" title="1.注册驱动"></a>1.注册驱动</h4><p>a).普通方式注册驱动</p><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DriverManager</span>.</span></span>register<span class="hljs-constructor">Driver(<span class="hljs-params">new</span> <span class="hljs-params">com</span>.<span class="hljs-params">mysql</span>.<span class="hljs-params">jdbc</span>.Driver)</span>;<br></code></pre></td></tr></table></figure><p>b).利用反射，用类加载器的方式注册驱动</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Class</span>.</span></span><span class="hljs-keyword">for</span><span class="hljs-constructor">Name(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="2-建立-Java-与数据库的联系"><a href="#2-建立-Java-与数据库的联系" class="headerlink" title="2.建立 Java 与数据库的联系"></a>2.建立 Java 与数据库的联系</h4><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">conn</span> = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/database&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;24694&quot;</span>)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><p>第一个参数是固定写法，代表了你连接的是哪个数据库，这里是 MySQL<br><em>说明：jdbc:mysql 类似于网络协议 https，这是固定写法。而 port 代表端口号</em><br>第二个参数是数据库用户名<br>第三个参数是数据库密码</p><h4 id="3-获得可操作的数据库对象"><a href="#3-获得可操作的数据库对象" class="headerlink" title="3.获得可操作的数据库对象"></a>3.获得可操作的数据库对象</h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">stmt</span> <span class="hljs-operator">=</span> conn.createStatement()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure><h4 id="4-执行-SQL-语句"><a href="#4-执行-SQL-语句" class="headerlink" title="4.执行 SQL 语句"></a>4.执行 SQL 语句</h4><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">//执行<span class="hljs-keyword">SQL</span>语句，会返回修改语句的条数，因为只涉及到一条操作，所以会返回<span class="hljs-number">1</span><br>String <span class="hljs-keyword">sql</span> = &quot;insert into test(age,name,local) values(50,&#x27;cofbro&#x27;,&#x27;China&#x27;)&quot;;<br><span class="hljs-type">int</span> num = stmt.<span class="hljs-keyword">execute</span>(<span class="hljs-keyword">sql</span>);<br></code></pre></td></tr></table></figure><p>下面直接贴上完整代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DatabaseDemo</span> &#123;<br>    <span class="hljs-type">Connection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">Statement</span> <span class="hljs-variable">stmt</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//注册驱动</span><br>            DriverManager.registerDriver(<span class="hljs-keyword">new</span> <span class="hljs-title class_">com</span>.mysql.jdbc.Driver);<br>            <span class="hljs-comment">//建立JVM与数据库的连接</span><br>            conn = DriverManager.getConnection(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/database&quot;</span>, <span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-string">&quot;24694&quot;</span>);<br>            <span class="hljs-comment">//获取数据库操作对象</span><br>            stmt = conn.createStatement();<br>            <span class="hljs-comment">//执行SQL语句，会返回修改语句的条数，因为只涉及到一条操作，所以会返回1</span><br>            <span class="hljs-type">String</span> <span class="hljs-variable">sql</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;insert into test(age,name,local) values(50,&#x27;cofbro&#x27;,&#x27;China&#x27;)&quot;</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">num</span> <span class="hljs-operator">=</span> stmt.execute(sql);<br>            <span class="hljs-comment">//查看是否修改成功</span><br>            System.out.println(num == <span class="hljs-number">1</span> ? <span class="hljs-string">&quot;保存成功&quot;</span> : <span class="hljs-string">&quot;保存失败&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>            <span class="hljs-comment">//若有异常，打印出异常信息</span><br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放资源</span><br>            <span class="hljs-keyword">if</span> (stnt != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//先关小的，才能关上大的</span><br>                    stmt.close();<br>                &#125; <span class="hljs-keyword">catch</span> (SQLException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (conn != <span class="hljs-literal">null</span>)&#123;<br>                        conn.close();<br>                    &#125;<br>                &#125;<span class="hljs-keyword">catch</span> (SQLException e)&#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Android动态广播(android8.0)</title>
    <link href="/2022/05/07/Android%E5%8A%A8%E6%80%81%E5%B9%BF%E6%92%AD-android8-0/"/>
    <url>/2022/05/07/Android%E5%8A%A8%E6%80%81%E5%B9%BF%E6%92%AD-android8-0/</url>
    
    <content type="html"><![CDATA[<h2 id="Android-广播事件"><a href="#Android-广播事件" class="headerlink" title="Android 广播事件"></a>Android 广播事件</h2><h3 id="1-广播注册分类"><a href="#1-广播注册分类" class="headerlink" title="(1).广播注册分类"></a>(1).广播注册分类</h3><h4 id="a-动态注册-在-UI-中注册的广播，例如："><a href="#a-动态注册-在-UI-中注册的广播，例如：" class="headerlink" title="(a).动态注册 在 UI 中注册的广播，例如："></a>(a).动态注册 在 UI 中注册的广播，例如：</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml">IntentFilter intentFilter = <span class="hljs-keyword">new</span> <span class="hljs-constructor">IntentFilter()</span>;<br><span class="hljs-comment">//实现了Parcelable接口，可用于过滤广播</span><br>intentFilter.add<span class="hljs-constructor">Action(Constants.ACTION_SEND_MSG)</span>;<br><span class="hljs-comment">//设置过滤器，规定能接受的广播信号</span><br>MessageReceiver messageReceiver = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MessageReceiver()</span>;<br>this.register<span class="hljs-constructor">Receiver(<span class="hljs-params">messageReceiver</span>,<span class="hljs-params">intentFilter</span>)</span>;<br><span class="hljs-comment">//注册广播</span><br></code></pre></td></tr></table></figure><h4 id="b-静态注册"><a href="#b-静态注册" class="headerlink" title="(b).静态注册"></a>(b).静态注册</h4><p>需要在 manifest 中进行注册（在安卓 8.0 后系统废除了大部分静态广播，最好使用动态注册）。</p><h3 id="2-广播类型分类"><a href="#2-广播类型分类" class="headerlink" title="(2).广播类型分类"></a>(2).广播类型分类</h3><h4 id="a-系统广播"><a href="#a-系统广播" class="headerlink" title="(a).系统广播"></a>(a).系统广播</h4><p>系统中已经定义的广播，此类广播只能由系统发出，并且需要在 intent-filter 中加上系统已经写的 action。</p><h4 id="b-自定义广播"><a href="#b-自定义广播" class="headerlink" title="(b).自定义广播"></a>(b).自定义广播</h4><div class="code-wrapper"><pre><code class="hljs">顾名思义，是用户自己定义的广播。</code></pre></div><h3 id="3-动态实现广播"><a href="#3-动态实现广播" class="headerlink" title="(3).动态实现广播"></a>(3).动态实现广播</h3><h4 id="a-我们首先需要一个广播接收类"><a href="#a-我们首先需要一个广播接收类" class="headerlink" title="(a)我们首先需要一个广播接收类"></a>(a)我们首先需要一个广播接收类</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs scala"> public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BroadcastReceiver</span></span>&#123;<br>        <span class="hljs-comment">//新建一个自己的广播接受类继承自BroadcastReceiver</span><br><br>        <span class="hljs-meta">@Override</span><br>        public void onReceive(<span class="hljs-type">Context</span> context, <span class="hljs-type">Intent</span> intent) &#123;<br>            <span class="hljs-comment">//重写onReceive方法，此方法写自己需要实现的逻辑</span><br>            <span class="hljs-type">String</span> detail = intent.getStringExtra(<span class="hljs-type">Constants</span>.<span class="hljs-type">KEY_CONTENT</span>);<br>            <span class="hljs-type">Toast</span>.makeText(<span class="hljs-type">SecondActivity</span>.<span class="hljs-keyword">this</span>, detail, <span class="hljs-type">Toast</span>.<span class="hljs-type">LENGTH_SHORT</span>).show();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="a-其次注册动态广播"><a href="#a-其次注册动态广播" class="headerlink" title="(a)其次注册动态广播"></a>(a)其次注册动态广播</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">MessageReceiver messageReceiver = <span class="hljs-keyword">new</span> <span class="hljs-constructor">MessageReceiver()</span>;<br>this.register<span class="hljs-constructor">Receiver(<span class="hljs-params">messageReceiver</span>,<span class="hljs-params">intentFilter</span>)</span>;<br></code></pre></td></tr></table></figure><h4 id="c-最后需要通过-send-方法发送一个广播供广播接收者接受"><a href="#c-最后需要通过-send-方法发送一个广播供广播接收者接受" class="headerlink" title="(c)最后需要通过 send 方法发送一个广播供广播接收者接受"></a>(c)最后需要通过 send 方法发送一个广播供广播接收者接受</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public void send(View v)&#123;<br>       String content = mInputBox.get<span class="hljs-constructor">Text()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">String()</span>;<br>       <span class="hljs-comment">//获取输入框中的值</span><br>       Intent intent = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Intent()</span>;<br>       intent.set<span class="hljs-constructor">Action(Constants.ACTION_SEND_MSG)</span>;<br>       <span class="hljs-comment">//设置action发送哪个广播，Constant类中书写的是常量</span><br>       intent.put<span class="hljs-constructor">Extra(Constants.KEY_CONTENT,<span class="hljs-params">content</span>)</span>;<br>       <span class="hljs-comment">//通过intent携带额外数据</span><br>       send<span class="hljs-constructor">Broadcast(<span class="hljs-params">intent</span>)</span>;<br>       <span class="hljs-comment">//发送广播</span><br>   &#125;<br></code></pre></td></tr></table></figure><p>整个过程完毕</p>]]></content>
    
    
    <categories>
      
      <category>Android学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Android</tag>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法练习：无重复字符的最长子串（滑动窗口）</title>
    <link href="/2022/05/07/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/"/>
    <url>/2022/05/07/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>今天遇到了这种找出无重复字符的最长子串的算法题，小编思来想去依旧没有想到有什么好方法，直到看到了大佬的算法，极为震撼，想写篇博客，记录下来。</p><p>题目如下：给出一组字符串，如 s &#x3D; “ adsjkhf ”，返回值为 7，s &#x3D; “abb”，返回值为 2，s &#x3D; “aab”，返回值为 2。请判断此字符串中无重复字符的最长子串。</p><h2 id="二-补充"><a href="#二-补充" class="headerlink" title="二.补充"></a>二.补充</h2><p>Java HashMap 中的方法：</p><p>get() 方法获取指定 key 对应对 value：map.get(key)</p><p>put() 方法将指定的键&#x2F;值对插入到 HashMap 中：map.put(key,value)</p><p>containsKey()方法如果 map 中存在指定的 key 对应的映射关系返回 true，否则返回 false。</p><h2 id="三-题解"><a href="#三-题解" class="headerlink" title="三.题解"></a>三.题解</h2><p>本题主要通过滑动窗口的思想解决。那么什么是滑动窗口呢？其实就是类似于两个前后指针，两个指针不断向后移，我们只关注指针中间的数，最后返回指针中间的元素的个数。</p><h4 id="1-分析"><a href="#1-分析" class="headerlink" title="(1) 分析"></a>(1) 分析</h4><p>我们先定义一个 map 容器用于存放字符串中的每个字符，然后从字符串的第一个字符 a 开始（ i &#x3D; 0 ）开始找，此时 map 里面是没有这个元素的，因此我们把 a 存放进 map 中，继续执行此操作直到出现 map 中有相同的字符，此时只需把 left 指针指向相同元素的后一位，两个指针中间的部分就是不重复字符的子串，此时这个子串的长度就为 i - left + 1。我们只需要用这个方法往后看去（随着 i 增加，即后指针向后指去），寻找是否有比当前子串长度更大的，若遇到则将现在的长度替换即可。</p><p>注意：字符串可能是这样的 –&gt; “ abbac”。按照我们的方法，会先将 ab 存入到我们的 map 当中，此时 left &#x3D; 0，当 i&#x3D;2 时，由于 map 中已经有 b，因此 left 将等于 get(b) + 1 &#x3D; 2。随后 i 指针向后指去又遇到 map 已有元素 a，按照前面的算法，此刻 left &#x3D; get(a) + 1 &#x3D; 1,但实际上 left 不会变，仍然等于 2，因此在求 left 值时总应该取最大的那个。</p><h4 id="2-代码详解"><a href="#2-代码详解" class="headerlink" title="(2) 代码详解"></a>(2) 代码详解</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><pre><code class="hljs reasonml"><br>public <span class="hljs-built_in">int</span> length<span class="hljs-constructor">OfLongestSubstring(String <span class="hljs-params">s</span>)</span> &#123;<br><br>       <span class="hljs-built_in">int</span> maxLen = <span class="hljs-number">0</span>;<span class="hljs-comment">//记录最长的的无重复字符串的长度</span><br><br>        <span class="hljs-built_in">int</span> left = <span class="hljs-number">0</span>;<span class="hljs-comment">//前指针</span><br><br>        HashMap&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;<span class="hljs-literal">()</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;s.length<span class="hljs-literal">()</span>;i++)&#123;<br><br>            <span class="hljs-keyword">if</span> (map.contains<span class="hljs-constructor">Key(<span class="hljs-params">s</span>.<span class="hljs-params">charAt</span>(<span class="hljs-params">i</span>)</span>))&#123;    <span class="hljs-comment">//若map中有此元素则执行下面代码</span><br><br>                left = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(left,map.get(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>)+<span class="hljs-number">1</span>);  <span class="hljs-comment">//上面已经解释，此处应一直取较大的left</span><br><br>            &#125;<br><br>            map.put(s.<span class="hljs-built_in">char</span><span class="hljs-constructor">At(<span class="hljs-params">i</span>)</span>,i);       <span class="hljs-comment">//将s中的第i个元素存入map中</span><br><br>            maxLen = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>max(maxLen,i -left + <span class="hljs-number">1</span>);  <span class="hljs-comment">//maxLen即为两个指针中间的元素个数</span><br><br>        &#125;<br><br>        return maxLen;<br><br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="3-图解"><a href="#3-图解" class="headerlink" title="(3) 图解"></a>(3) 图解</h4><p>最初 left&#x3D;0，i&#x3D;0，map 中无任何元素，此时 map 中将添加 a 字符</p><p>此时 i&#x3D;1，map 中将添加 b 字符</p><p>此时 i&#x3D;2，map 中将添加 c 字符</p><p>此时 i&#x3D;3，检测到 map 中已有 a，left 将指向到 map 中的 a 的后一位 b<br>以此类推遍历完字符串直到 i &#x3D; s.length()，返回最后的 maxLen 即为最终答案。</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>算法练习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>扑克比大小(Java&amp;Kotlin)</title>
    <link href="/2022/05/06/My-New-Post/"/>
    <url>/2022/05/06/My-New-Post/</url>
    
    <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>想要具备面向对象的思维，多写代码必不可少，今天记录的是一个能迅速使大家建立起面向对象思维的一个小 Demo<span id="more"></span>：从一副扑克中抽出 2 张牌来进行比较，具体如下：</p><div class="note note-success">            <p><em>1.此副牌大小顺序为 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A.</em><br><em>2.若点数相同则比较花色 ♠ &lt; ♥ &lt; ♣ &lt; ♦ .</em><br><em>注意：一副扑克中没有相同的两张牌.</em></p>          </div><h2 id="二-思考"><a href="#二-思考" class="headerlink" title="二.思考"></a>二.思考</h2><p>既然讲到面向对象的思维，那么在敲代码前一定要好好思考下比较两张扑克所包含的动作和事物有哪些？首先可以确定的是需要一副扑克，那么这固然是一类（Poker 类），只有有了扑克我们才能比大小，然而扑克就只是扑克吗，扑克中包含了哪些东西 ?点数和花色？那么这又是两类（PokerNumber 类和 PokerSuit 类），由于扑克牌是由点数和花色组成的，那么也就是说 PokerNumber 类和 PokerSuiit 类与 Poker 类是聚合关系。我们明白了扑克的组成，那么又是怎样将牌发出去从而比较大小的呢？这里就需要一个 PokerManager 来初始化扑克（我们的目的是实例化对象后就能将牌初始化，正好可以用构造方法）并将其发出去。</p><p>整个过程的 UML 图如下：<br><img src="https://upload-images.jianshu.io/upload_images/28033194-5c1753dbcb4edc77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整个UML概览"></p><ul><li>简单介绍一下过程：我们是通过 PokerNumber 和 PokerSuit 来组成单一的扑克牌的，而这一张扑克是要被收到一起组成一副扑克，换句话说就是需要被 PokerManager 集中起来统一创建管理。在 PokerManager 中定义两个数组分别储存点数和花色。我们知道 PokerManager 中有很多 Poker，那 Poker 又是怎么来的呢，这就需要剩下的两个类组成它了：PokerNumber 和 PokerSuit。分别代表扑克点数和花色，这样一张扑克就诞生了。</li></ul><h4 id="1-创建-PokerNumber-类与-PokerSuit-类"><a href="#1-创建-PokerNumber-类与-PokerSuit-类" class="headerlink" title="1.创建 PokerNumber 类与 PokerSuit 类"></a>1.创建 PokerNumber 类与 PokerSuit 类</h4><p>为什么要创建这两类呢？是因为我们需要在创建花色和点数的时候就要为之后比大小做准备。我们一旦将点数和花色确定为字符串类型的时候，就无法通过 String 来比大小，只能再引入一个变量 tag（tag 为花色数组和点数数组的索引），通过 tag 来比较，因此要把这两个属性分装起来成为一个类。</p><h5 id="a-PokerNumber-类"><a href="#a-PokerNumber-类" class="headerlink" title="a).PokerNumber 类"></a>a).PokerNumber 类</h5><figure class="highlight typescript"><table><tr><td class="gutter"><div class="code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PokerNumber</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title class_">String</span> <span class="hljs-built_in">number</span>;<br>    <span class="hljs-keyword">private</span> int tag;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">PokerNumber</span>(<span class="hljs-title class_">String</span> <span class="hljs-built_in">number</span>, int tag) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">number</span> = <span class="hljs-built_in">number</span>;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">getNumber</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">number</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setNumber</span>(<span class="hljs-params"><span class="hljs-built_in">String</span> <span class="hljs-built_in">number</span></span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">number</span> = <span class="hljs-built_in">number</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> int <span class="hljs-title function_">getTag</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">return</span> tag;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">setTag</span>(<span class="hljs-params">int tag</span>) &#123;<br>        <span class="hljs-variable language_">this</span>.<span class="hljs-property">tag</span> = tag;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="b-PokerSuit-类"><a href="#b-PokerSuit-类" class="headerlink" title="b).PokerSuit 类"></a>b).PokerSuit 类</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">PokerSuit</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">String</span> suit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> tag;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PokerSuit</span><span class="hljs-params">(<span class="hljs-type">String</span> suit, <span class="hljs-type">int</span> tag)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.suit = suit;<br>        <span class="hljs-keyword">this</span>.tag = tag;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">String</span> <span class="hljs-title">getSuit</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> suit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">setSuit</span><span class="hljs-params">(<span class="hljs-type">String</span> suit)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.suit = suit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title">getTag</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> tag;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">void</span> <span class="hljs-title">setTag</span><span class="hljs-params">(<span class="hljs-type">int</span> tag)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tag = tag;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-创建-Poker-类"><a href="#2-创建-Poker-类" class="headerlink" title="2.创建 Poker 类"></a>2.创建 Poker 类</h4><p>Poker 类中包含 PokerNumber 和 PokerSuit 属性。此外还应在此类写出比较扑克大小的方法并且重写 toString()方法修改 poker 输出格式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Poker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> PokerNumber pokerNumber;<br>    <span class="hljs-keyword">private</span> PokerSuit pokerSuit;<br>    <span class="hljs-comment">//初始化poker的两个属性 -&gt; 点数和花色</span><br>    <span class="hljs-keyword">public</span> Poker(PokerNumber pokerNumber, PokerSuit pokerSuit) &#123;<br>        <span class="hljs-keyword">this</span>.pokerNumber = pokerNumber;<br>        <span class="hljs-keyword">this</span>.pokerSuit = pokerSuit;<br>    &#125;<br>    <span class="hljs-comment">//比较扑克牌大小</span><br>    <span class="hljs-keyword">public</span> boolean compareTo(Poker poker)&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.pokerNumber.getTag() == poker.pokerNumber.getTag())&#123;<br>            <span class="hljs-comment">//点数相同的情况下，若前者花色大与后者花色则返回true</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pokerSuit.getTag() &gt; poker.pokerSuit.getTag();<br>        <span class="hljs-comment">//点数大与后者，则返回true</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.pokerNumber.getTag() &gt; poker.pokerNumber.getTag();<br>    &#125;<br>     <span class="hljs-comment">//重写toString() 格式化poker的输出格式</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String toString() &#123;<br>        <span class="hljs-keyword">return</span><br>                 pokerNumber.getNumber() +<br>                 pokerSuit.getSuit();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-创建-PokerManager-类"><a href="#3-创建-PokerManager-类" class="headerlink" title="3.创建 PokerManager 类"></a>3.创建 PokerManager 类</h4><p>PokerManager 类用于集中创建和管理扑克。并且我们要通过此类 getPoker 方法得到一张具体扑克。</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-keyword">class</span> PokerManager &#123;<br>    ArrayList&lt;Poker&gt; pokers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;<span class="hljs-literal">()</span>;<span class="hljs-comment">//创建Poker类集合存放每一张扑克</span><br>    public <span class="hljs-constructor">PokerManager()</span>&#123;<br>        String<span class="hljs-literal">[]</span> numbers = &#123;<span class="hljs-string">&quot;2&quot;</span>, <span class="hljs-string">&quot;3&quot;</span>, <span class="hljs-string">&quot;4&quot;</span>, <span class="hljs-string">&quot;5&quot;</span>, <span class="hljs-string">&quot;6&quot;</span>, <span class="hljs-string">&quot;7&quot;</span>, <span class="hljs-string">&quot;8&quot;</span>, <span class="hljs-string">&quot;9&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>, <span class="hljs-string">&quot;J&quot;</span>, <span class="hljs-string">&quot;Q&quot;</span>, <span class="hljs-string">&quot;K&quot;</span>, <span class="hljs-string">&quot;A&quot;</span>&#125;;<br>        String<span class="hljs-literal">[]</span> suits = &#123;<span class="hljs-string">&quot;♦&quot;</span>, <span class="hljs-string">&quot;♣&quot;</span>, <span class="hljs-string">&quot;♥&quot;</span>, <span class="hljs-string">&quot;♠&quot;</span>&#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; numbers.length; i++)&#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> j = <span class="hljs-number">0</span>; j&lt; suits.length; j++)&#123;<br>                <span class="hljs-comment">//通过两层for循环创建扑克，外层循环确定点数，内层循环确定花色</span><br>                pokers.add(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Poker(<span class="hljs-params">new</span> PokerNumber(<span class="hljs-params">numbers</span>[<span class="hljs-params">i</span>],<span class="hljs-params">i</span>)</span>,<span class="hljs-keyword">new</span> <span class="hljs-constructor">PokerSuit(<span class="hljs-params">suits</span>[<span class="hljs-params">j</span>],<span class="hljs-params">j</span>)</span>));<br>                <span class="hljs-comment">//将创建出来的扑克存进pokers集合里</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//取出扑克的方法</span><br>    public Poker get<span class="hljs-constructor">Poker()</span>&#123;<br>        Random r = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Random()</span>;<br>        <span class="hljs-built_in">int</span> index = r.next<span class="hljs-constructor">Int(<span class="hljs-params">pokers</span>.<span class="hljs-params">size</span>()</span>);<br>        <span class="hljs-comment">//得到[0,pokers集合长度]大小的随机数</span><br>        Poker poker = pokers.get(index);<span class="hljs-comment">//拿到对应索引处的扑克</span><br>        pokers.remove(index);<span class="hljs-comment">//去重，已经拿到过的扑克牌应从这副牌中删去</span><br>        return poker;<span class="hljs-comment">//返回扑克对象</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-创建-Test-类，测试代码"><a href="#4-创建-Test-类，测试代码" class="headerlink" title="4.创建 Test 类，测试代码"></a>4.创建 Test 类，测试代码</h4><p>接下来就是运行代码，查看结果是否与预期相符</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Poker poker2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Poker poker1;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] args</span>)</span> &#123;<br>        PokerManager pokerManager = <span class="hljs-keyword">new</span> PokerManager();<br>        <span class="hljs-comment">//实例化对象，得到两张扑克牌</span><br>        poker1 = pokerManager.getPoker();<br>        poker2 = pokerManager.getPoker();<br>        <span class="hljs-comment">//调用compareTo方法判断大小，并输出判定结果</span><br>        <span class="hljs-keyword">if</span> (poker1.compareTo(poker2))&#123;<br>            System.<span class="hljs-keyword">out</span>.println(poker1 + <span class="hljs-string">&quot;&gt;&quot;</span> + poker2);<br>        &#125;<span class="hljs-keyword">else</span><br>            System.<span class="hljs-keyword">out</span>.println(poker1 + <span class="hljs-string">&quot;&lt;&quot;</span> + poker2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5.运行结果"></a>5.运行结果</h4><p><img src="https://upload-images.jianshu.io/upload_images/28033194-2822d9331ccc07e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/28033194-b8bd69732e47bcdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/28033194-cd7f119357feecb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>先记录到 Java…</p>]]></content>
    
    
    <categories>
      
      <category>Diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>Kotlin</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
