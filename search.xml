<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>算法练习：不同的二叉搜索树（动态规划）</title>
      <link href="/2022/06/02/unique-binary-search-trees/"/>
      <url>/2022/06/02/unique-binary-search-trees/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>LeetCode 题目：<a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a><br>给你一个整数 n ，求恰由 n 个节点组成且节点值从 1 到 n 互不相同的 二叉搜索树 有多少种？返回满足题意的二叉搜索树的种数。</p><p><code>示例 1：</code></p><blockquote><p>输入：n &#x3D; 3<br>输出：5</p></blockquote><p><code>示例2：</code></p><blockquote><p>输入：n &#x3D; 1<br>输出：1</p></blockquote><p>题目很简洁，但是分析起来却有点复杂，首先搞清楚什么是二叉搜索树。二叉搜索树分为左子树和右子树，左子树还能再分为左子树和右子树，就像这样：<br><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fpic4.zhimg.com%2Fv2-06ce569cea6d80d3a649ff69b4de1cc4_1440w.jpg%3Fsource%3D172ae18b&refer=http%3A%2F%2Fpic4.zhimg.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1656745281&t=9da45f912e7d67e118a778a2b40aa5f7"></p><p>二叉搜索树有三个条件：</p><ol><li>若它的左子树不空，则左子树上所有结点的值均小于它的<a href="https://baike.baidu.com/item/%E6%A0%B9%E7%BB%93%E7%82%B9/9795570">根结点</a>的值</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值</li><li>它的左、右子树也分别为二叉搜索树</li></ol><h2 id="二-分析思考"><a href="#二-分析思考" class="headerlink" title="二.分析思考"></a>二.分析思考</h2><p>我们将 dp 数组定义为 1 到 n 互不相同的二叉搜索树的个数，先来尝试写写 <code>n = 1</code> 和 <code>n = 2</code>的情况<br><img src="https://s1.328888.xyz/2022/06/02/WeHL2.png"></p><p>这两个其实还挺简单的，再来看看 <code>n = 3</code> 的时候<br><img src="https://s1.328888.xyz/2022/06/02/We884.png"><br>这个时候不同的二叉搜索树就有 5 个了，我们来看看这五个是怎么根据前面的结果推导出来的。此图片中前两棵树是根据 dp[2]中的第一个二叉搜索树得出来的，他们结构都是一样的，都是没有左子树，右子树有两个结点。而 dp[3]中的第三和第四棵树同理和 dp[2]中的第二棵树结构相同。</p><p>那么 dp[3]中最后一棵树是怎么来的呢，我们将眼光放宽一点，这时候会发现它和 dp[1]中那棵树结构很相似！</p><p>继续探索一下这个规律：</p><ul><li>二叉搜索树当以 <code>1</code> 为起点时，它的个数为右子树的个数 dp[2]；</li><li>二叉搜索树当以 <code>2</code> 为起点时，它的个数为右子树的个数 dp[1] * 左子树的个数 dp[1]；</li><li>二叉搜索树当以 <code>3</code> 为起点时，它的个数为左子树的个数 dp[2]；<br>则总共的二叉搜索树为：<code>dp[2] + dp[1] * dp[1] + dp[2]</code><br><em>注：定义 dp[0] &#x3D; 1，使之符合下面通式的规律</em></li></ul><p>我们将这个规律扩展到 <code>n</code>，我们需要计算出从 1 到 n 为起点的每一个二叉搜索树的个数，因此需要循环来遍历，则总共的二叉搜索树为：<code>dp[i] += dp[i - j] * dp[j -1]</code>，其中<code>i</code> 为外层循环且<code>i &lt;= n</code>，<code>j</code> 为内层循环且 <code>j &lt;= i</code>。<br>为了验证一下这个规律，我们继续往下写一组二叉搜索树，当<code>n = 4</code>时<br><img src="https://s1.328888.xyz/2022/06/02/We53C.png"></p><p>其中二叉搜索树为个数为：<code>dp[0] * dp[3] + dp[1] * dp[2] + dp[2] * dp[1] + dp[3] * dp[0] = 14</code>，确实符合上述规律…</p><h2 id="三-代码"><a href="#三-代码" class="headerlink" title="三.代码"></a>三.代码</h2><p>分析完了，现在就来看看代码，如果还有点疑惑说不定看了代码就豁然开朗了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numTrees(int n) &#123;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        dp[0] = 1;</span><br><span class="line">        dp[1] = 1;</span><br><span class="line">        for(int i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">            for(int j = 1; j &lt;= i; j++)&#123;</span><br><span class="line">                dp[i] += dp[i - j] * dp[j -1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ps.虽然代码只有这么点，但是分析和思考过程却远远不止这点，要想掌握动态规划还得多加练习和总结啊。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法练习 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin之lambda 表达式与高阶函数</title>
      <link href="/2022/06/02/lambda/"/>
      <url>/2022/06/02/lambda/</url>
      
        <content type="html"><![CDATA[<h2 id="一-lambda-表达式"><a href="#一-lambda-表达式" class="headerlink" title="一.lambda 表达式"></a>一.lambda 表达式</h2><p>lambda 在 Java 里面也有，不过 Kotlin 中的 lambda 使用起来更方便、更灵活。<br>lambda 其实就是匿名函数，能使代码变得更加灵活简洁，其表达式为: <code>&#123;变量定义 -&gt; 代码块&#125;</code> ， 如：<code>&#123; a, b -&gt; a + b &#125;</code></p><blockquote><p>lambda 函数是一个可以接收任意多个参数(包括可选参数)并且返回单个表达式值的函数</p></blockquote><p>1、lambda 函数比较轻便，即用即仍，很适合需要完成一项功能，但是此功能只在此一处使用，连名字都很随意的情况下；<br>2、匿名函数，一般用来给 filter， map 这样的函数式编程服务;<br>3、作为回调函数，传递给某些应用，比如消息处理</p><ul><li>完整的 <code>lambda</code> 表达式</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val method: (num1: Int, num2: Int) -&gt; Boolean = &#123; a: Int,b: Int -&gt;</span><br><span class="line">        a &lt; b</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>完整语法形式的参数声明放在圆括号内，其中 <code>num1</code> 和 <code>num2</code>只是变量的声明，可以不写，但是后面的函数体必须定义相应的变量（a，b），并有可选的类型标注， 函数体跟在一个 <code>-&gt;</code> 符号之后。如果推断出的该 <code>lambda</code> 的返回类型不是 <code>Unit</code>，那么该 lambda 主体中的最后一个（或可能是单个） 表达式会视为返回值。</p><p>关于 <code>-&gt;</code>:<br>a.其参数（如果有的话）在 -&gt; 之前声明<br>b.函数体（如果存在的话）在 -&gt; 后面</p><ul><li>因此 <code>lambda</code> 表达式可以简化成下面这种</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val method: (Int, Int) -&gt; Boolean = &#123; a, b -&gt;</span><br><span class="line">        a &lt; b //函数体中最后一行表达式即为 lambda 的返回值</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>还能省略函数的声明，只留下函数体</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">val method= &#123; a: Int, b: Int -&gt; a &lt; b &#125;//Kotlin可以自动推断返回类型，也可省略返回值类型的声明</span><br></pre></td></tr></table></figure><ul><li>当 <code>lambda</code> 中有未用到的参数时可以用 <code>_</code> 表示</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val method: (num1: Int, num2: Int) -&gt; Boolean = &#123; _, _ -&gt;</span><br><span class="line">        true</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二-高阶函数"><a href="#二-高阶函数" class="headerlink" title="二.高阶函数"></a>二.高阶函数</h2><p>高阶函数就是以函数为参数的一种特殊的函数，通常与 <code>lambda</code> 配合起来一起使用，即 <code>lambda</code> 作为参数。</p><ul><li>高阶函数的声明实现与调用</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">val sum = &#123; x: Int -&gt; x&#125;</span><br><span class="line"></span><br><span class="line">fun method(age: Int, lambda: (a: Int) -&gt; Int): Int &#123;</span><br><span class="line">        return lambda(10 * age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">method(10, sum)</span><br></pre></td></tr></table></figure><ul><li>当然高阶函数调用参数也可以直接放 <code>lambda</code></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fun method(age: Int, lambda: (a: Int) -&gt; Int): Int &#123;</span><br><span class="line">        return lambda(10 * age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">method(10, lambda = &#123; a -&gt; a.and(20) &#125;)</span><br></pre></td></tr></table></figure><ul><li>it 隐式参数<br>当 <code>lambda</code> 中只有一个参数时，你不必再去单独定义一个变量来接收它，Kotlin 提供了 <code>it</code> 参数，代表的是你声明 <code>lambda</code> 时定义的那个唯一参数。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">fun method(age: Int, lambda: (a: Int) -&gt; Int): Int &#123;</span><br><span class="line">        return lambda(10 * age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">method(10, lambda = &#123;it.and(20)&#125;)//这里的 it 就是前面声明中的 a</span><br></pre></td></tr></table></figure><ul><li>当高阶函数中的最后一个参数是 <code>lambda</code> 表达式时，<code>lambda</code>可以放在圆括号外面</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">fun method(age: Int, lambda: (a: Int) -&gt; Int): Int &#123;</span><br><span class="line">        return lambda(10 * age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">method(10)&#123;</span><br><span class="line">        it.and(20)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//当高阶函数只有 lambda 作为参数时，圆括号也能省略</span><br><span class="line">fun myMethod(lambda: (a: Int) -&gt; Int): Int &#123;</span><br><span class="line">        return lambda(10 * age)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">myMethod &#123;</span><br><span class="line">        it.and(20)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="三-拓展函数与高阶函数"><a href="#三-拓展函数与高阶函数" class="headerlink" title="三.拓展函数与高阶函数"></a>三.拓展函数与高阶函数</h2><p>扩展函数是指在一个类上增加一种新的函数（方法），通常在某个类后面加 <code>.</code> 和 <code> 方法名</code>，我们先来看看普通的扩展函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fun String.myPrint()&#123;</span><br><span class="line">    println(this)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在熟悉普通的扩展函数之后，我们往里面加一个 <code>泛型</code> 和 <code>lambda</code> 进去：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Standard.kt是Kotlin库的一部分，它定义了一些基本inline函数。</span><br><span class="line">//在c/c++中，为了解决一些频繁调用的小函数大量消耗栈空间的问题</span><br><span class="line">//特别的引入了inline修饰符，表示为内联函数</span><br><span class="line">inline fun &lt;T&gt; T.myAlso(block: (T) -&gt; Unit): Unit &#123;</span><br><span class="line">    //泛型表示任何类型，只有在调用的时候才会判断你写的属于哪个类型</span><br><span class="line">    block(this)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Person是个类，里面有个属性 age</span><br><span class="line">val p = Person(10)//age = 10</span><br><span class="line"></span><br><span class="line">p.myAlso &#123;</span><br><span class="line">        it.age = 30//将 p 的 age 修改为30</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>当 <code>lambda</code> 也是一个扩展函数时</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">inline fun &lt;T&gt; T.myApply(block: T.() -&gt; T): T &#123;</span><br><span class="line">    return this.block()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//Person是个类，里面有个属性 age</span><br><span class="line">val p = Person(10)</span><br><span class="line">    p.myApply &#123;</span><br><span class="line">        this.age = 20//将 p 的 age 修改为20</span><br><span class="line">        this//lambda 返回值</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法练习：整数拆分（动态规划）</title>
      <link href="/2022/05/30/integer-break/"/>
      <url>/2022/05/30/integer-break/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>最近一直在了解动态规划，这是 LeetCode 上面的一道动规的题。</p><p><a href="https://leetcode.cn/problems/integer-break/">343. 整数拆分</a></p><p>给定一个正整数  <code>n</code> ，将其拆分为  <code>k</code>  个  <strong>正整数</strong>  的和（ <code>k &gt;= 2</code> ），并使这些整数的乘积最大化。<br>返回  <em>你可以获得的最大乘积</em> 。</p><p><code>示例1：</code></p><blockquote><p>输入: n &#x3D; 2<br>输出: 1<br>解释: 2 &#x3D; 1 + 1, 1 × 1 &#x3D; 1。</p></blockquote><p><code>示例2：</code></p><blockquote><p>输入: n &#x3D; 10<br>输出: 36</p></blockquote><p>解释: 10 &#x3D; 3 + 3 + 4, 3 × 3 × 4 &#x3D; 36。</p><hr><h2 id="二-思路"><a href="#二-思路" class="headerlink" title="二.思路"></a>二.思路</h2><p>说到动态规划，我认为最重要的就是确定自己的 <code>dp数组</code> 的含义，其次就是 <code>递推公式</code> 了。</p><ul><li>确定 <code>dp[i]</code> 的含义</li></ul><p>我们重新浏览一遍题，给定一个正整数 <code>n</code> ，需要将它分成若干个整数，返回最大的乘积。因此我们可以定义 <code>dp[i]</code> 表示每个正整数拆分为若干个正整数所对应的最大乘积，若要确定 <code>dp[i]</code> 的值，我们可以根据 <code>dp[i]</code> 以前的元素进行运算从而得到最大的<br><code>dp[i]</code> 的值。</p><ul><li>确定 <code>dp[i]</code> 的值</li></ul><p><code>dp[i]</code> 的值是由两种方式来共同确定的。<br>第一，<code>dp[i] = dp[i - j] * j</code> 其中 <code>i</code> 代表外层循环， <code>j</code> 代表内层循环，<code>j</code> 从 <code>1</code> 开始逐个求出 <code>dp[i]</code> ，最后取最大值。<br>第二，<code>dp[i]</code> &#x3D; <code>(i - j) * j</code>，同上，也是取最大值。上面那种方式是将 <code>i</code> 分成了 <code>n</code> 个 <code>(n &gt; 2)</code>。而这种方式是将 <code>i</code> 分成了<code>n</code> 个 <code>(n = 2)</code>。</p><ul><li>确定递推公式</li></ul><p>其实到这里，递推公式大致样式也就出来了:<br><code>dp[i] = Math.max(dp[i], Math.max(dp[i - j] * j, (i - j) * j))</code> ，那么可能会有人问为什么还要比较一次 <code>dp[i]</code> 呢？因为我们内层循环中一周后，会算出很多 <code>dp[i]</code> ，我们只需要保存最大的 <code>dp[i]</code>。</p><hr><h2 id="三-代码"><a href="#三-代码" class="headerlink" title="三.代码"></a>三.代码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int integerBreak(int n) &#123;</span><br><span class="line">        int[] dp = new int[n + 1];</span><br><span class="line">        //dp[2]对应的值应该是1，而dp[2]之前的元素在此问题中无实际意义，因此无需初始化</span><br><span class="line">        dp[2] = 1;</span><br><span class="line">        for(int i = 3; i &lt;= n; i++)&#123;</span><br><span class="line">            for(int j = 1; j &lt;= i - j; j++)&#123;</span><br><span class="line">                dp[i] = Math.max(dp[i], Math.max(dp[i - j] * j, j * (i - j)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度 O(n^2)</p><ul><li>题外话<br>这道题用动态规划的话时间复杂度似乎有点高，其实这道题可以用数学方法来写的，这里用到一个结论：当整数 <code>n</code> 尽可能地等分为 <code>3</code>时乘积最大。如果感兴趣的同学可以去证明一下。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int integerBreak(int n) &#123;</span><br><span class="line">        if(n &lt;= 3) return n - 1;</span><br><span class="line">        int a = n / 3, b = n % 3;</span><br><span class="line">        //当 n 分刚好能分成若干个 3 时</span><br><span class="line">        if(b == 0) return (int)Math.pow(3, a);</span><br><span class="line">        //当 n 尽可能分成 3 时，余出一个 1</span><br><span class="line">        if(b == 1) return (int)Math.pow(3, a - 1) * 4;</span><br><span class="line">        //当 n 尽可能分成 3 时，余出一个 2</span><br><span class="line">        return (int)Math.pow(3, a) * 2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>时间复杂度：O(1)</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法练习 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo更换主题之Butterfly</title>
      <link href="/2022/05/27/ChengeToButterfly/"/>
      <url>/2022/05/27/ChengeToButterfly/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>前段时间搭建好了 Hexo 框架并用上了 Fluid 主题，后来不知道怎么回事，我的 Fluid 主题出了点问题，正好对我来说 Fluid 主题有点太简约了，索性换了一个 Butterfly 主题。下面说的一些配置的效果可以参考我的博客：<a href="https://cofbro.github.io/">cofbro 的博客 - Hello I’m cofbro</a><br>如果还没有安装 Hexo，可以看看这篇文章——<a href="https://www.jianshu.com/p/265ff281e159">Hello Hexo！一款高效的个人博客框架 </a></p><h2 id="二-Butterfly-的下载"><a href="#二-Butterfly-的下载" class="headerlink" title="二.Butterfly 的下载"></a>二.Butterfly 的下载</h2><p>打开你的 Hexo 根目录，点击鼠标右键，进入 <code>Git Bash Here</code>，输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i hexo-theme-butterfly</span><br></pre></td></tr></table></figure><p>随后咱们依次进入 <code>Hexo -&gt; themes -&gt; butterfly</code> 找到 <code>_config.yml</code> 文件，将里面的内容复制到 Hexo 根目录中的 <code>_config.butterfly.yml(如果没有就创建)</code>。</p><h2 id="三-关于-Butterfly-配置"><a href="#三-关于-Butterfly-配置" class="headerlink" title="三.关于 Butterfly 配置"></a>三.关于 Butterfly 配置</h2><blockquote><p>注意：本文仅展示部分配置，如需更多请参考<a href="https://butterfly.js.org/">Butterfly - A Simple and Card UI Design theme for Hexo</a></p></blockquote><h3 id="1-config-yml-中的配置"><a href="#1-config-yml-中的配置" class="headerlink" title="1._config.yml 中的配置"></a>1._config.yml 中的配置</h3><ul><li><p>打开根目录中的 <code>_config.yml</code> 文件，找到 <code>theme</code> 将其修改为 <code>Butterfly</code> ，以后配置更改就在这里面。</p></li><li><p>看板娘功能：需要先安装</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-helper-live2d</span><br></pre></td></tr></table></figure><p>再进入 <code>_config.yml</code> 在最后加上：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">live2d:</span><br><span class="line">    enable: true #是否显示看板娘</span><br><span class="line">    scriptFrom: local</span><br><span class="line">    model:</span><br><span class="line">        use: live2d-widget-model-tororo #需要与后面的命令相同，直接更换名字即可</span><br><span class="line">    display:</span><br><span class="line">        position: left #宽高以及位置自己看着调</span><br><span class="line">        width: 200</span><br><span class="line">        height: 300</span><br><span class="line">    mobile:</span><br><span class="line">        show: true #是否在手机进行显示</span><br></pre></td></tr></table></figure><p>在通过 npm 下载对应的模型</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install live2d-widget-model-tororo #对应的模型命令，这是只小白猫</span><br></pre></td></tr></table></figure><p>其他的模型见<a href="https://blog.csdn.net/wang_123_zy/article/details/87181892"> Hexo 添加 Live2D 看板娘+模型预览</a></p><h3 id="2-config-butterfly-yml-中的配置"><a href="#2-config-butterfly-yml-中的配置" class="headerlink" title="2._config.butterfly.yml 中的配置"></a>2._config.butterfly.yml 中的配置</h3><ul><li>创建页：<br>刚换主题后，除了主页好像都是需要你自己去创建的，下面这些命令就是创建页的：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about #创建关于页</span><br><span class="line"></span><br><span class="line">hexo new page tags #创建标签页</span><br><span class="line"></span><br><span class="line">hexo new page categories #创建分类页</span><br><span class="line"></span><br><span class="line">hexo new page categories #创建分类页</span><br><span class="line"></span><br><span class="line">hexo new page link #创建友链页</span><br></pre></td></tr></table></figure><ul><li>其他基础配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">    首页: / || fas fa-home</span><br><span class="line">    归档: /archives/ || fas fa-archive</span><br><span class="line">    标签: /tags/ || fas fa-tags</span><br><span class="line">    分类: /categories/ || fas fa-folder-open</span><br><span class="line">    #菜单||fas fa-list:</span><br><span class="line">    #音乐: /music/ || fas fa-music</span><br><span class="line">    #电影: /movies/ || fas fa-video</span><br><span class="line">    友链: /link/ || fas fa-link</span><br><span class="line">    关于: /about/ || fas fa-heart</span><br><span class="line"></span><br><span class="line">上面是一些右上角的标签，可以自定义选择</span><br></pre></td></tr></table></figure><ul><li>下面这个是局部搜索，不过需要通过 npm 安装</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">local_search:</span><br><span class="line">    enable: true</span><br><span class="line">    preload: false</span><br><span class="line">    CDN:</span><br><span class="line">    labels:</span><br><span class="line">    input_placeholder: Search for Posts</span><br><span class="line">    hits_empty: &quot;We didn&#x27;t find any results for the search: $&#123;query&#125;&quot;</span><br><span class="line"># 如果没有查到内容相关内容显示</span><br></pre></td></tr></table></figure><ul><li>打字机效果</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">subtitle:</span><br><span class="line">    enable: true</span><br><span class="line">    # Typewriter Effect (打字效果)</span><br><span class="line">    effect: true</span><br><span class="line">    # loop (循環打字)</span><br><span class="line">    loop: true</span><br><span class="line">    # source 調用第三方服務</span><br><span class="line">    # source: true</span><br><span class="line">    # source: 1 https://hitokoto.cn/</span><br><span class="line">    # source: 2 http://yijuzhan.com/</span><br><span class="line">    # source: 3 https://www.jinrishici.com/</span><br><span class="line">    # subtitle 會先顯示 source , 再顯示 sub 的內容</span><br><span class="line">    source: 4</span><br><span class="line">    # 如果關閉打字效果，subtitle 只會顯示 sub 的第一行文字</span><br><span class="line">    sub:</span><br><span class="line">        - 梦想这东西和经典一样 永远不会因为时间而褪色</span><br><span class="line">        - 何其荣幸 何德何能 #注意这里的格式   空格和 &#x27;-&#x27;</span><br></pre></td></tr></table></figure><ul><li>鼠标点击特效</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">activate_power_mode:</span><br><span class="line">    enable: false</span><br><span class="line">    colorful: true # open particle animation (冒光特效)</span><br><span class="line">    shake: true #  open shake (抖動特效)</span><br><span class="line">    mobile: false</span><br><span class="line"></span><br><span class="line"># Mouse click effects: fireworks (鼠標點擊效果: 煙火特效)</span><br><span class="line">fireworks:</span><br><span class="line">    enable: true</span><br><span class="line">    zIndex: 9999 # -1 or 9999</span><br><span class="line">    mobile: false</span><br><span class="line"></span><br><span class="line"># Mouse click effects: Heart symbol (鼠標點擊效果: 愛心)</span><br><span class="line">click_heart:</span><br><span class="line">    enable: false</span><br><span class="line">    mobile: false</span><br><span class="line"></span><br><span class="line"># Mouse click effects: words (鼠標點擊效果: 文字)</span><br><span class="line">ClickShowText:</span><br><span class="line">    enable: false</span><br><span class="line">    text:</span><br><span class="line">        # - I</span><br><span class="line">        # - LOVE</span><br><span class="line">        # - YOU</span><br><span class="line">    fontSize: 15px</span><br><span class="line">    random: false</span><br><span class="line">    mobile: false</span><br></pre></td></tr></table></figure><p><em>提示：主题中很多 <code>js</code> 是通过 CDN 服务下载的，Butterfly 用的 <code>jsdeliver</code> 在国内已经 g 了，如果想要正常显示特效请在 <code>_config.butterfly.yml</code> 找到 <code>CDN</code> 。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">CDN:</span><br><span class="line">    # The CDN provider of internal scripts (主題內部 js 的 cdn 配置)</span><br><span class="line">    # option: local/jsdelivr</span><br><span class="line">    # Dev version cannot choose jsdelivr (dev版的主題不能設置為 jsdelivr)</span><br><span class="line">    internal_provider: local</span><br><span class="line">    # The CDN provider of third party scripts (第三方 js 的 cdn 配置)</span><br><span class="line">    # option: local/jsdelivr</span><br><span class="line">    # when set it to local, you need to install hexo-butterfly-extjs</span><br><span class="line">    third_party_provider: local #在这里改为local</span><br><span class="line">    option:</span><br></pre></td></tr></table></figure><p>之后依然要用到命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-extjs</span><br></pre></td></tr></table></figure><p>如果报错：npm WARN deprecated <a href="mailto:&#102;&#x6f;&#x72;&#x6d;&#105;&#x64;&#97;&#x62;&#108;&#101;&#x40;&#x31;&#x2e;&#x32;&#46;&#54;">&#102;&#x6f;&#x72;&#x6d;&#105;&#x64;&#97;&#x62;&#108;&#101;&#x40;&#x31;&#x2e;&#x32;&#46;&#54;</a>: Please upgrade to latest, formidable@v2 or formidable@v3! Check these notes: <a href="https://bit.ly/2ZEqIau">https://bit.ly/2ZEqIau</a></p><p>则先键入以下命令，就可以在本地加载 js 文件了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install formidable@v3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo更换主题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法练习：只有两个键的键盘（数学法，动态规划）</title>
      <link href="/2022/05/26/zhi-you-liang-ge-jian-de-jian-pan-by-lee-ussa/"/>
      <url>/2022/05/26/zhi-you-liang-ge-jian-de-jian-pan-by-lee-ussa/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>又到了记录代码的时候了，这道题来自 LeetCode，<a href="https://leetcode.cn/problems/2-keys-keyboard/">只有两个键的键盘</a>：</p><p>最初记事本上只有一个字符 ‘A’ 。你每次可以对这个记事本进行两种操作：<br>Copy All（复制全部）：复制这个记事本中的所有字符（不允许仅复制部分字符）。<br>Paste（粘贴）：粘贴 上一次 复制的字符。<br>给你一个数字  n ，你需要使用最少的操作次数，在记事本上输出 恰好  n  个 ‘A’ 。返回能够打印出  n  个 ‘A’ 的最少操作次数。</p><p>下面给出两个例子：<br><code>示例1：</code></p><blockquote><p>输入：3<br>输出：3<br>解释：<br>最初, 只有一个字符 ‘A’。<br>第 1 步, 使用 Copy All 操作。<br>第 2 步, 使用 Paste 操作来获得 ‘AA’。<br>第 3 步, 使用 Paste 操作来获得 ‘AAA’。</p></blockquote><p><code>示例2：</code></p><blockquote><p>输入：n &#x3D; 1<br>输出：0</p></blockquote><h2 id="二-题解"><a href="#二-题解" class="headerlink" title="二.题解"></a>二.题解</h2><p>首先说说笔者写这道题的经历吧，不怕大家笑话，这道题我足足写了 3 小时…最开始看到这道题的时候我想的是我可以将 n 以前的操作 <code>A</code> 的次数以次数为键用 <code>Hashmap</code> 存起来，然后遇到 <code>n</code> 的时候直接去 <code>Hashmap</code> 里面拿，当我去提交的时候，发现有些测试用例是过不了的，比若说 741。然后我重新思考，发现可以用递归，比如 <code>n = 24</code>，但是由于思考深度不够，又有一些情况没考虑到，去提交的又数次失败…</p><p>由于递归从最开始就没考虑到那种情况，因此改起来特别麻烦，而这不得不使我重新选择一条路出发。所以由此看来啊，做题之前真要静下心来思考，思考范围要广一点。</p><p>接下来就说第一种方法，我称之为数学规律法。</p><h3 id="1-数学规律法"><a href="#1-数学规律法" class="headerlink" title="1.数学规律法"></a>1.数学规律法</h3><p>先举一些简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">当输入不同的 n 时，对应输出的值：</span><br><span class="line"></span><br><span class="line">1 = 0</span><br><span class="line">2 = 1 2 --&gt; 2次//因为需要复制一次，粘贴一次，因此是2</span><br><span class="line">7 = 1 2 3 4 5 6 7 --&gt; 7次// 1 + 1 + 1 + 1 + 1 + 1 + 1 = 7</span><br><span class="line">12 = 1 2 3 6 12 --&gt; 6次 //2 + 1 + 2 + 2 = 7</span><br><span class="line">18 = 1 2 3 6 9 18 --&gt; 8次 //2 + 1 + 2 + 1 +2 = 8</span><br><span class="line">25 = 1 2 3 4 5 10 15 20 25 --&gt; 10次 //2 + 1 + 1 + 2 +1 + 1 + 1 + 1 = 10</span><br><span class="line">741 = 35次 --&gt; 这个待会讲</span><br></pre></td></tr></table></figure><p>既然是数学方法，当然要运用强大的数学规律，我们仔细观察一番会发现：如果是质数那么它的最小操作次数就是它本身，对于非质数，比如说 <code>12</code> ，上面得出 <code>6</code> 次答案的过程我们倒着看分成 3 个片段,12 &lt;- 6 || 6 &lt;- 3 || 3 &lt;- 2 &lt;- 1。</p><p>首先来看 12 &lt;- 6 这一个片段，<code>6</code> 如果要成为 <code>12</code> 必须先全部复制再粘贴，也就是说这里会有 2 次操作；再看 6 &lt;- 3，<code>3</code> 如果要成为 <code>6</code> 也必须先全部复制再粘贴，也会有 2 次操作；最后看 3 &lt;- 2 &lt;- 1 这个片段，<code>1</code> 如果要成为 <code>3</code> 需要全部复制、粘贴、粘贴，也就是要 3 次。我们再来看看这样一个东西：<code>12</code> 除以 <code>2</code> 等于 <code>6</code>，这里操作次数+2，<code>6</code> 除以 <code>2</code> 等于 <code>3</code>，这里操作次数+2，<code>3</code> 除以 <code>3</code> 等于 <code>1</code>，这里操作次数+3。2 + 2 + 3 &#x3D; 6。你会惊奇的发现：只需要找到能整除 n 的除数，之后全部加起来就等于最后答案了。</p><p>不相信？再来试一个！<code>25</code> 除以 <code>5</code> 等于 <code>5</code>，操作次数+5；<code>5</code> 除以 <code>5</code> 等于 <code>1</code>，操作次数+5，最终答案：5 + 5 &#x3D; 10。是不是感觉有点神奇？其实这就是质因数的分解，<code>25</code> 能分成 <code> 5</code> 和 <code>5</code>。<code>12</code> 能分成 <code>2</code> 和 <code>2</code> 和 <code>3</code> ，因此最小操作数为 7。因此最上面的 <code>741</code> 分解质因数为 <code>19</code> 和 <code>13</code> 和 <code>3</code>，所以其最小操作数为 <code>35</code>。</p><p>这种方法接近双百，附图：<br><img src="https://s3.bmp.ovh/imgs/2022/05/26/226699885901c278.webp"></p><h4 id="a-数学规律法代码"><a href="#a-数学规律法代码" class="headerlink" title="a).数学规律法代码"></a>a).数学规律法代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minSteps(int n) &#123;</span><br><span class="line">        int result = 0;</span><br><span class="line">        int i;</span><br><span class="line">        //当 n 被分解到 1 时，退出循环</span><br><span class="line">        while(n != 1)&#123;</span><br><span class="line">            for( i = 2; i &lt;= n; i++)&#123;</span><br><span class="line">            //遍历找出能整除 n 的 i</span><br><span class="line">                if(n % i == 0)&#123;</span><br><span class="line">                    n /= i;</span><br><span class="line">                    //result加上能整除 n 的 i</span><br><span class="line">                    result += i;</span><br><span class="line">                    i = 2;//成功整除 n 后，进行新的 i 循环，找出下一个能整除 n 的i</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h3 id="2-动态规划-LeetCode-官方题解"><a href="#2-动态规划-LeetCode-官方题解" class="headerlink" title="2.动态规划(LeetCode 官方题解)"></a><a href="https://leetcode.cn/problems/2-keys-keyboard/">2.动态规划(LeetCode 官方题解)</a></h3><h5 id="1-动态规划技巧"><a href="#1-动态规划技巧" class="headerlink" title="1.动态规划技巧"></a>1.动态规划技巧</h5><p>先简单说说动态规划的一些技巧吧。</p><ul><li>确定好 dp 数组的含义，一定要理解 dp[i]所表示的是什么</li><li>动态规划的数据通常是由前面一个数据推导演变而来的，因此需要得出推导公式</li><li>最后就是 dp 数组的初始化了，这个需要额外注意，因为初始化一旦有问题，就会导致最终答案出错</li></ul><h5 id="2-思路"><a href="#2-思路" class="headerlink" title="2.思路"></a>2.思路</h5><p>举个例子，还是拿 <code>12</code> 来说吧，<code>12 = 1 -&gt; 2 -&gt; 3 -&gt; 6 -&gt; 12</code>，我们会发现要得出 <code>12</code> 的最小操作次数，需要知道 <code>6</code> 的最小操作次数再加上复制粘贴的次数（2 次），进而需要知道 <code>3</code> 的最小操作次数再加上复制粘贴的次数（2 次）…总的来说就是如果要找出 <code>i</code> 个 <code>A</code> ，则必定要先找到 <code>i</code> 的因数 <code>j</code> ,而后通过 <code>i / j</code> 次复制粘贴得到 <code>i</code> 个 <code>A</code> 因此会发现这个递推规律：<br><img src="https://s3.bmp.ovh/imgs/2022/05/26/a0cf0451b9b0ab5f.webp" alt="递推公式"><br>其中， <code>j | i</code> 表示 <code>j</code> 能整除 <code>i</code> ，<code>i / j</code> 表示复制粘贴的次数。对于每一个 <code>dp[i]</code> 只需要等于最小的 <code>f[j] + i / j</code>。</p><hr><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int minSteps(int n) &#123;</span><br><span class="line">        int[] f = new int[n + 1];</span><br><span class="line">        for (int i = 2; i &lt;= n; ++i) &#123;</span><br><span class="line">            f[i] = Integer.MAX_VALUE;</span><br><span class="line">            for (int j = 1; j &lt;= i; ++j) &#123;</span><br><span class="line">                if (i % j == 0) &#123;</span><br><span class="line">                    f[i] = Math.min(f[i], f[j] + i / j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return f[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法练习 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法练习：回文子字符串的个数（多种方法）</title>
      <link href="/2022/05/26/huiwenZiChuan/"/>
      <url>/2022/05/26/huiwenZiChuan/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>今天介绍一道相对简单的练习题，同样是来自 LeetCode。</p><p><a href="https://leetcode.cn/problems/a7VOhD/">回文子字符串的个数，给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</a></p><p><code>示例1：</code></p><blockquote><p>输入：s &#x3D; “abc”<br>输出：3<br>解释：三个回文子串: “a”, “b”, “c”</p></blockquote><p><code>示例2：</code></p><blockquote><p>输入：s &#x3D; “aaa”<br>输出：6<br>解释：6 个回文子串: “a”, “a”, “a”, “aa”, “aa”, “aaa”</p></blockquote><p>题目来源：<a href="https://leetcode.cn/problems/a7VOhD/">LeetCode</a></p><h2 id="二-题解"><a href="#二-题解" class="headerlink" title="二.题解"></a>二.题解</h2><p>其实关于回文的题有很多种，而解法更是多种多样，今天介绍两种方法，<code>递归</code>和<code>中心拓展</code>。</p><h4 id="1-递归"><a href="#1-递归" class="headerlink" title="1.递归"></a>1.递归</h4><p>简单来说递归就是一个函数调用自己本身的行为就叫递归。递归具有代码简洁，易读的特点，但是缺点也不容忽视：</p><p>a).运行效率较低。<br>b).可能会导致栈溢出，如果递归次数太多，需要在内存栈中分配空间以保存参数以及临时变量就会过多，当超出栈的容量，就会导致栈溢出。</p><p>我们思路是这样的：首先通过遍历找到所有的子串，然后再判断子串是否是回文。那么怎么判断是否是回文呢？比如这样的一个字符串<code>abcba</code>,我们判断其是否为回文，可以先判断第一个和最后一个字符是否相同，再判断第二个字符和倒数第二个字符是否相同…直到全部判断完毕，这个过程中，我们反复做着相同的工作，因此可以使用递归，来看看代码吧：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countSubstrings(String s) &#123;</span><br><span class="line">        int result = 0;//最终结果</span><br><span class="line">        //两层循环，从字符串首部开始遍历处所有子字符串</span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            for (int j = i; j &lt; s.length(); j++) &#123;</span><br><span class="line">                //每个子字符串调用isHuiwen，若返回 true 则 result + 1</span><br><span class="line">                if (isHuiwen(s, i, j)) &#123;</span><br><span class="line">                    result++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">    //isHuiwen需要三个参数，s 是字符串，i 是子字符串第一个字符，j 是子字符串的最后一个字符</span><br><span class="line">    public static boolean isHuiwen(String s, int i, int j) &#123;</span><br><span class="line">        //两种情况返回true（1,2）</span><br><span class="line">        //1.当子字符串的长度是奇数时，此时回文中心只有一个，当递归到 i == j时，说明全部首尾字符判断完毕，全部相等，返回true</span><br><span class="line">        if (i == j) return true;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (s.charAt(i) != s.charAt(j)) &#123;</span><br><span class="line">                //如果二者不相等，直接返回false，退出递归</span><br><span class="line">                return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                //2.当子字符串的长度为偶数，此时回文中心是两个字符，由于上面的if中已经判断 i 和 j是相同的</span><br><span class="line">                //因此到这里也将首尾字符全部判断完毕，全部相等，返回true</span><br><span class="line">                if (i + 1 == j) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125; else return isHuiwen(s, ++i, --j);</span><br><span class="line">                //如果程序走到这儿，说明不满足上面任意一种情况，因此在调用函数进一步判断 ++i 和 --j 是否相等</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们上面这种方法找出子字符串需要两层循环，时间复杂度为 O(n^2) 而判断它是否为回文又是 O(n)，因此总的复杂度为 O(n^3)。显然效率不高，那我们再来看看<a href="https://leetcode.cn/problems/a7VOhD/solution/hui-wen-zi-zi-fu-chuan-de-ge-shu-by-leet-ejfv/">LeetCode 官方题解吧</a>！——中心拓展</p><h4 id="2-中心拓展"><a href="#2-中心拓展" class="headerlink" title="2.中心拓展"></a>2.中心拓展</h4><p>大致思路：我们从每一个可能成为回文中心的点开始，若前后字符相等就拓展，反之，则停止拓展。</p><p>当子字符串是奇数时，回文中心是一个；当子字符串是偶数个时，回文中心是两个。有没有一种方法可以统一二者呢？答案是有的。通过规律我们可以发现：无论子字符串长度是偶数还是奇数，我们都需要遍历 <code>2n - 1</code> 次字符串，换句话说就是有 <code>2n - 1</code> 个回文中心，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countSubstrings(String s) &#123;</span><br><span class="line">        int n = s.length(), ans = 0;</span><br><span class="line">        for (int i = 0; i &lt; 2 * n - 1; ++i) &#123;</span><br><span class="line">            //向前拓展从i开始，向后拓展从r开始</span><br><span class="line">            int l = i / 2, r = i / 2 + i % 2;</span><br><span class="line">            //当子字符串个数为偶数时，i 和 r 相等</span><br><span class="line">            while (l &gt;= 0 &amp;&amp; r &lt; n &amp;&amp; s.charAt(l) == s.charAt(r)) &#123;</span><br><span class="line">                //当前后字符相等且 i 和 r 未越界时</span><br><span class="line">                //开始向两边拓展</span><br><span class="line">                --l;</span><br><span class="line">                ++r;</span><br><span class="line">                ++ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乘积小于 K 的子数组（滑动窗口）</title>
      <link href="/2022/05/25/%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8E-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/"/>
      <url>/2022/05/25/%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8E-K-%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>今天奉上的题是来自<a href="https://leetcode.cn/problems/subarray-product-less-than-k/">LeetCode</a>中的一道中等难度的题，但是如果了解滑动窗口的思想，其实这道题也是比较简单的，题目如下：</p><p>给你一个整数数组  <code>nums</code>  和一个整数  <code>k</code> ，请你返回子数组内所有元素的乘积严格小于<code>k</code>  的连续子数组的数目。</p><div class="note success simple"><p><code>示例一：</code></p><p>输入：nums &#x3D; [10,5,2,6], k &#x3D; 100<br>输出：8<br>解释：8 个乘积小于 100 的子数组分别为：[10]、[5]、[2],、[6]、[10,5]、[5,2]、[2,6]、[5,2,6]。<br>需要注意的是 [10,5,2] 并不是乘积小于 100 的子数组。</p><p><code>示例二：</code></p><p>输入：nums &#x3D; [1,2,3], k &#x3D; 0<br>输出：0</p></div><hr><h2 id="二-思考"><a href="#二-思考" class="headerlink" title="二.思考"></a>二.思考</h2><p>像这种从一个数组里面找一些子数组或者子字符串的问题大都可往这方面靠，一般来说都是可以解决的。因此我们大致思路是这样的，同样定义两个指针（一个叫 left，一个叫 i），它们都指向数组的第一个元素。我们用 i 指针来遍历数组，每当 i 指向新的元素时我们都计算 i 指针和 left 指针之间（窗口之间）元素的积并判断一下是否小于 k，若成立则当前子数组就符合条件，用 n 来记录一次。反之，则 i 继续移动下去。</p><p>具体的我们看着代码来解释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numSubarrayProductLessThanK(int[] nums, int k) &#123;</span><br><span class="line">        int left = 0，i = 0;//定义左指针和右指针</span><br><span class="line">        int n = 0;//用来记录子数组的个数</span><br><span class="line">        int addtion = 1;//表示子数组中元素的积</span><br><span class="line">        while(left &lt; nums.length)&#123;//首先判断循环条件，当left指针指向nums的最后一个元素时，循环结束</span><br><span class="line">            //循环进来后，计算i和left之间各元素的积</span><br><span class="line">            addtion *= nums[i];</span><br><span class="line">            i++;//i指针向后移动</span><br><span class="line">            if (addtion &gt;= k)&#123;//若子数组中的各元素积大于k</span><br><span class="line">                left++;//说明子数组中元素超出条件范围，将left指针向右移动</span><br><span class="line">                //让i重新和left指向同一元素，开始新一轮的查找，因此addtion也要归为原始状态</span><br><span class="line">                i = left;</span><br><span class="line">                addtion = 1;</span><br><span class="line">            &#125;else n++;//若符合条件，则记录一下，使n+1</span><br><span class="line">            //但是还有一种情况，i到left之间的子数组都符合条件，这时i指向了数组的最后一个元素</span><br><span class="line">            if (i == nums.length)&#123;</span><br><span class="line">                //不能使i越界，因此将两个指针重新合到一块，重新开始新的查找，同理依然重置addtion</span><br><span class="line">                i = left + 1;</span><br><span class="line">                left++;</span><br><span class="line">                addtion = 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return n;//返回最后结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="三-再次思考"><a href="#三-再次思考" class="headerlink" title="三.再次思考"></a>三.再次思考</h2><p>如果理解了上面这个做法的话，那让我们想想是否还有更优解呢？<br>在上面这个做法中，我们每开始一次新的查找，都需要将 i 指针和 left 指针重新指向同一个新的元素，并且 addtion 也需要重置为 1，这样看来这其中确实有不妥之处，那让我们来看看官方的的做法吧。<br><code>LeetCode官方题解：</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int numSubarrayProductLessThanK(int[] nums, int k) &#123;</span><br><span class="line">        int n = nums.length, ret = 0;</span><br><span class="line">        int prod = 1, i = 0;//prod相当于我们之前的addtion</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            prod *= nums[j];</span><br><span class="line">            //官方给出的代码中以下和我们之前的方法有一点差异</span><br><span class="line">            while (i &lt;= j &amp;&amp; prod &gt;= k) &#123;</span><br><span class="line">                prod /= nums[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ret += j - i + 1;//这是i和j指针之间的元素个数，它在数值上等于新增符合条件的子数组个数</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>思路与分析：整体思想和我们最开始讲的是一样的，只不过在记录子数组个数和重置各元素积这两部进行了优化。</p><p>我们着重讲述 while 中有差异的这段，我们可以这么理解：i 指针相当于第一种方法的 left，j 指针相当于之前的 i。这里 while 中有一个 <code>i &lt;= j</code> 条件，这是用来控制 i 指针的范围的，也就是说 i 指针是不能超过 j 指针的，这样就会有一个好处：因为 <code>j &lt; n</code>，所以 i 就不会超出数组的长度了，也就能避免我们第一种方法还要专门写个<code>if</code>来判断 i 是否越界，简化了代码。代码进入循环后，也就意味着 <code>prod &gt; k</code> 了，这时我们为了符合条件，需要把 i 指针向后移动，而 prod 值只需要除以<code>nums[i]</code>就等于此时窗口中元素的值。这和我们第一种方法相比就显得非常优秀了，我们之前的方法需要每次把 prod 值归 1，然后由要经历 prod 等于原来那个值的过程，这就显得有点多余了。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法练习：统计好数字的数目（快速幂）</title>
      <link href="/2022/05/13/fastMi/"/>
      <url>/2022/05/13/fastMi/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>又是在力扣被题折磨的一次，反反复复地提交，反反复复的不通过，不过还好了解到了快速幂的思想，这种方式能大幅提高程序的运行速度。</p><blockquote><p>题目：我们称一个数字字符串是 好数字 当它满足（下标从 0  开始）偶数 下标处的数字为 偶数   且 奇数   下标处的数字为 质数  （2，3，5  或  7）。</p></blockquote><ul><li>比方说，”2582”  是好数字，因为偶数下标处的数字（2  和  8）是偶数且奇数下标处的数字（5 和  2）为质数。但  “3245”  不是 好数字，因为  3  在偶数下标处但不是偶数。<br>给你一个整数  n ，请你返回长度为  n  且为好数字的数字字符串   总数  。由于答案可能会很大，请你将它对  109 + 7  取余后返回  。</li></ul><p>一个 数字字符串   是每一位都由  0  到 9  组成的字符串，且可能包含前导 0.<a href="https://leetcode.cn/problems/count-good-numbers/">(题目来源：LeetCode）</a></p><h2 id="二-分析"><a href="#二-分析" class="headerlink" title="二.分析"></a>二.分析</h2><p>这道题乍一看似乎挺简单，由于是让我们返回好数字的个数，对于偶数下标来说符合条件的无非就 0,2,4,6,8 这几个数字，而奇数下标只有 1,3,5,7 这四个数字。我们只需要计算每一位上符合条件的数字的个数之积，顶多再模上 1000000007 就是最终答案了。但是真的是这样的吗？</p><ul><li>敲完代码直接提交（自信加蔑视）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int countGoodNumbers(long n) &#123;</span><br><span class="line">        double result = 0;</span><br><span class="line">        if (n % 2 == 0)&#123;</span><br><span class="line">            result = (Math.pow(4,n/2) * Math.pow(5,n/2)) % 1000000007;</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            result = (Math.pow(4,n/2) * Math.pow(5,n/2 + 1)) % 1000000007;</span><br><span class="line">        &#125;</span><br><span class="line">        return (int) result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>心想这不就完了吗，很难吗？但是最终结果就是它死活不让我过，卡在了 50：<br><img src="https://s3.bmp.ovh/imgs/2022/05/12/9cda7a82442d9a34.webp" alt="迷茫啊..."><br>我***，这哪有什么问题，这都不让过？离谱啊…… 思考一番无果我只能去翻翻源码，这一下又让我有了新的收获：<br><img src="https://s3.bmp.ovh/imgs/2022/05/12/7c450cf14f75d653.webp"><br>它是一个本地方法，也就是由 c&#x2F;c++编写的方法，java 能拿来用，而这个 pow 方法返回四舍五入到最接近的 int 值的参数值，而 int 最多只能表示 2147483647（2 的 31 次方-1），但是代码里面的 5 的 50 次方早就超过了其最大值，因此这里已经溢出，错误也就随之产生了。</p><p>行，那我就换个方法，不用这个 pow 方法，我自己写一个能得到指数值的方法不就好了吗？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 说明：这里举个例子，想简单告诉一下大家这种循环计算时会非常耗时间</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static long normalCal(int power, int base) &#123;</span><br><span class="line">        long result = 1;</span><br><span class="line">        for (int i = 0; i &lt; power; i++) &#123;</span><br><span class="line">            result = result * base;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        long result = normalCal(30,5 );</span><br><span class="line"></span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们求的是 5 的 30 次方，那么就会执行 30 次循环。不难发现其时间复杂度为 O(N),其中 N 为指数。在我们这段代码中还好，要是我换成 5 的 100 次方呢？那么会有以下两个问题：</p><ul><li>1.假如真的是 5 的 200 次方，即使我们用 long 接收，结果也会溢出的，这又会回到前面的问题上去。</li><li>2.就算我们想尽办法正确得到了这个结果，但这会花费大量的时间，这样提交上去肯定会超时，最终也会不成功。<br>那么是否有一种二者问题都解决掉的方案呢？答案肯定是有的，这就是之前我们将要说到的快速幂思想。</li></ul><h2 id="三-快速幂思想"><a href="#三-快速幂思想" class="headerlink" title="三.快速幂思想"></a>三.快速幂思想</h2><p><em>我们先来初步认识下快速幂，给定一个 2 的 12 次方式子让你计算，你拿到这个题后会怎么想呢？</em></p><ul><li>为了计算的简便，我们通常可以将 2 的 12 次方转换为 4 的 6 次方进而转成 16 的 4 次方…进行计算。</li></ul><hr><p>1.快速幂正好是这种思想，在计算机中 2 的 12 次方要循环 12 次，而我们通过将指数减半，底数平方的思想可以减少循环的次数，从而提高性能。就比如上述的 2 的 12 次方：我们通过快速幂的思想思考它是这样的：2 的 12 次方 -&gt; 4 的 6 次方 -&gt; 16 的 3 次方 -&gt; 256 的 1 次方 乘以 16。前者循环了 12 次，而后者只需要循环 4 次，要是有更高指数计算，则能节省循环的次数也就不言而喻了。</p><p>那我们怎么解决因为计算出的值过大而溢出导致出错的问题呢？我们先来了解一下模的运算规律吧：<br><code>a). (a+b)%p=(a%p+b%p)%p</code><br><code>b). (a-b)%p=(a%p-b%p)%p</code><br><code>c). (a*b)%p=(a%p * b%p)%p</code> 2.在这里只需要用到第三条结论，我们可以在计算过程中就开始不断取模，而不是等到最终结果出来之后再模运算，这样就能避免最终答案太大导致出错的问题了。</p><p>因此在进行幂运算时我们可以这样做：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public long myAns(lon base, long index) &#123;</span><br><span class="line">    int k = 1000000007;</span><br><span class="line">    long result = 1;</span><br><span class="line">    while (index &gt; 0) &#123;//当指数减到1时跳出循环</span><br><span class="line">        if (index % 2 == 1) &#123;</span><br><span class="line">            //奇数往这儿走，由于这里是奇数，指数减半会有余数，因此我们只需多乘以一个原来的result就行了</span><br><span class="line">            index = index - 1;</span><br><span class="line">            result = result * base % k;//乘上原来的底数</span><br><span class="line">            base = base * base % k;//底数平方</span><br><span class="line">        &#125;else &#123;</span><br><span class="line">            //偶数来这里，这里就是正常的指数减半，底数平方</span><br><span class="line">            index = index / 2;</span><br><span class="line">            base = (base * base) % k;</span><br><span class="line">        &#125;</span><br><span class="line">    //我们可以看到这种方式节约的循环次数是指数级的</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面这个代码还能更精简一些，我们还能对它进行优化。<br>我们来看看整道题的全部代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    //优化后的代码，这个方法就是进行幂运算</span><br><span class="line">    public long findMyResult(long base, long index) &#123;</span><br><span class="line">        long result = 1;</span><br><span class="line">        while(index&gt; 0)&#123;</span><br><span class="line">            if(power % 2 == 1)&#123;</span><br><span class="line">                result = result * base % 1000000007;</span><br><span class="line">            &#125;</span><br><span class="line">            index = index / 2;//奇数除以2会舍去小数点后面的数，能自动实现减1操作</span><br><span class="line">            base = base * base % 1000000007;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public int countGoodNumbers(long n) &#123;</span><br><span class="line">        if(n % 2 == 0)&#123;</span><br><span class="line">            long result =  findMyResult(4,n/2) % 1000000007;</span><br><span class="line">            result = (result * findMyResult(5,n/2)) % 1000000007;</span><br><span class="line">            return (int) result;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            long result = (findMyResult(4,n/2) % 1000000007);</span><br><span class="line">            result = (result * findMyResult(5,n/2 + 1)) %  1000000007;</span><br><span class="line">            return (int) result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>完 ~</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello Hexo！一款高效的个人博客框架</title>
      <link href="/2022/05/12/mypost/"/>
      <url>/2022/05/12/mypost/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><h4 id="什么是-Hexo？"><a href="#什么是-Hexo？" class="headerlink" title="什么是 Hexo？"></a>什么是 Hexo？</h4><blockquote><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用  <a href="http://daringfireball.net/projects/markdown/">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p></blockquote><p>现在网上大多数的博客系统其实都是别人的框架，比较流行的框架有 WordPress， halo ， hugo 还有我们今天要讲的 Hexo。</p><h2 id="二-安装准备"><a href="#二-安装准备" class="headerlink" title="二.安装准备"></a>二.安装准备</h2><ul><li>本文部分代码可能失效，具体以<a href="https://hexo.io/zh-cn/docs/">官网 | Hexo</a>为准<br>由于 Hexo 是基于 Node.js 的，因此我们需要先下载 Node.js，另外只需要安装 git 工具就 ok 了。</li></ul><h4 id="1-安装Node-js"><a href="#1-安装Node-js" class="headerlink" title="1.安装Node.js"></a>1.安装<a href="https://nodejs.org/en/">Node.js</a></h4><p>傻瓜式安装，一直 next 即可。如有疑惑请自行上网搜索，网上安装教程很全，相信大家不会在这耽搁太多时间。安装完成后我们任意位置单击鼠标右键会有一个 Git Bash Here，点击后就会弹出 git 命令框了。<br><em>注意：若想要后面下载速度更快，请打开 git 输入以下命令</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry &quot;https://registry.npm.taobao.org&quot;</span><br></pre></td></tr></table></figure><h4 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2.安装Git "></a>2.安装<a href="https://git-scm.com/">Git </a></h4><p>上同。</p><h2 id="三-Hexo-安装"><a href="#三-Hexo-安装" class="headerlink" title="三.Hexo 安装"></a>三.Hexo 安装</h2><p>完成上述操作后即可开始安装 Hexo。我们通过 npm 来安装 hexo。桌面鼠标单机右键，打开 Git Bash Here。</p><ul><li>键入以下命令：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br></pre></td></tr></table></figure><ul><li>之后在指定路径新建文件夹（英文名），右键打开 git 命令框，输入指令：</li></ul><blockquote><p>踩坑点：千万要在你刚建好的文件夹中打开 git 命令框！</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init</span><br></pre></td></tr></table></figure><p>到这里 Hexo 就彻底安装完毕了。我们可以看到刚刚的文件夹里面新增了很多文件以及文件夹：<br><img src="https://s3.bmp.ovh/imgs/2022/05/12/d1f38c45ad2cbd15.jpg" alt="文件夹概览"></p><h2 id="四-Hexo-使用"><a href="#四-Hexo-使用" class="headerlink" title="四.Hexo 使用"></a>四.Hexo 使用</h2><h4 id="1-自定义配置"><a href="#1-自定义配置" class="headerlink" title="1.自定义配置"></a>1.自定义配置</h4><p>打开_config.yml 进行基础配置，比如修改你的博客的名字之类的，详情见<a href="https://hexo.io/zh-cn/docs/">官网 | Hexo</a><br><img src="https://s3.bmp.ovh/imgs/2022/05/12/3696058c67c12c00.webp"></p><h4 id="2-创建文章"><a href="#2-创建文章" class="headerlink" title="2.创建文章"></a>2.创建文章</h4><p>a).先整体说一下各个文件是干嘛的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── _config.yml  //这个是配置文件，用于修改文章数据的，点进去之后里面会有详细注解</span><br><span class="line">├── package.json //应用程序信息，依赖的模块列表</span><br><span class="line">├── scaffolds //包含三个文章模板，分别是draft，page，post。博客的定制修改会对模板进行修改。</span><br><span class="line">├── source //我们写的文章文件夹就存在这里，包括我们的 Markdown 文稿，这里面一般也可以新建一个文件夹用来放一些我们博客中需要用到的图片</span><br><span class="line">|   ├── _drafts //就是草稿</span><br><span class="line">|   └── _posts //这就是存文章的文件夹</span><br><span class="line">└── themes //用于修改Hexo主题的</span><br></pre></td></tr></table></figure><p>b).我们进入根目录，就是你刚刚新建的文件夹的名字<br><img src="https://s3.bmp.ovh/imgs/2022/05/12/7fb240132cd720cd.webp"></p><p>输入以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt;</span><br></pre></td></tr></table></figure><p>也可以不设置  <code>layout</code> ，默认使用  <a href="https://hexo.io/zh-cn/docs/configuration">_config.yml</a>  中的  <code>default_layout</code>  参数代替（默认是 post）。如果标题包含空格的话，请使用引号括起来。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;My First Post&quot;</span><br></pre></td></tr></table></figure><p>之后我们从根目录依次点击 source –&gt; _posts –&gt; My First Post.md 编辑文件。<br>进入之后他是长这样的：<br><img src="https://s3.bmp.ovh/imgs/2022/05/12/d1f38c45ad2cbd15.jpg"><br><code>---</code> 之间是 front-matter，是我们每篇文章的一些变量，我们可以在这里单独进行设置，也可以在_config.yml 中统一配置。而在<code>---</code>之外的地方就是我们写自己博客内容的位置了。需要注意要用 MarkDown 语法哦。<br>c).写完保存之后，在根目录再次打开 git 命令框输入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean</span><br></pre></td></tr></table></figure><ul><li>每次运行前建议 clean 一下缓存，免得出现一些奇奇怪怪的问题</li></ul><p>d).输入以下命令，生成静态网页文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>e).最后，输入下列代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s</span><br></pre></td></tr></table></figure><p>敲完回车后就在本地服务器上运行了，你的博客就可以在本地浏览了，方法：在浏览器 url 框中输入 <a href="http://localhost:4000/">http://localhost:4000</a> 即可查看。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>轻松理解JDBC并使用</title>
      <link href="/2022/05/08/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3JDBC%E5%B9%B6%E4%BD%BF%E7%94%A8/"/>
      <url>/2022/05/08/%E8%BD%BB%E6%9D%BE%E7%90%86%E8%A7%A3JDBC%E5%B9%B6%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>最近学习了 JDBC，觉得非常重要，因此连忙熬夜记录下来。</p><h2 id="二-什么是-JDBC？"><a href="#二-什么是-JDBC？" class="headerlink" title="二.什么是 JDBC？"></a>二.什么是 JDBC？</h2><blockquote><p>JDBC（Java Data Base Connectivity,java 数据库连接）是一种用于执行<a href="https://so.csdn.net/so/search?q=SQL%E8%AF%AD%E5%8F%A5&spm=1001.2101.3001.7020">SQL 语句</a>的 Java API，可以为多种关系数据库提供统一访问，它由一组用 Java 语言编写的类和接口组成。</p></blockquote><p>具体来说就是 Java 为了能够让用户操作不同的数据库而编写出来的一套标准接口，我们需要调用它从而能够操作不同的数据库。而像 MySQL，SQLite，SQLService 不同的厂商为了能让 Java 操作自己家的数据库也需要实现 Java 提供的接口，这些实现了 JDBC 接口的类打成一个 jar 包，也就是我待会提到的数据库驱动。</p><h2 id="三-JDBC-的五个步骤"><a href="#三-JDBC-的五个步骤" class="headerlink" title="三.JDBC 的五个步骤"></a>三.JDBC 的五个步骤</h2><p><em>1.注册驱动</em><br><em>2.建立 Java 与数据库的联系</em><br><em>3.获得可操作的数据库对象</em><br><em>4.执行 SQL 语句</em><br><em>5.查看结果</em></p><h2 id="四-补充："><a href="#四-补充：" class="headerlink" title="四.补充："></a>四.补充：</h2><h4 id="1-connection"><a href="#1-connection" class="headerlink" title="1.connection"></a>1.connection</h4><h5 id="a-解释："><a href="#a-解释：" class="headerlink" title="a).解释："></a>a).解释：</h5><p>Connection 与特定数据库的连接（会话），在连接上下文中执行 sql 语句并返回结果。</p><h5 id="b-常用方法："><a href="#b-常用方法：" class="headerlink" title="b).常用方法："></a>b).常用方法：</h5><ul><li>createStatement()：创建向数据库发送 sql 的 statement 对象。</li><li>prepareStatement(sql) ：创建向数据库发送预编译 sql 的 PrepareSatement 对象。</li><li>prepareCall(sql)：创建执行存储过程 callableStatement 对象。</li><li>setAutoCommit(boolean autoCommit)：设置事务是否自动提交。</li><li>commit() ：在链接上提交事务。</li><li>rollback() ：在此链接上回滚事务。</li></ul><h4 id="2-statement"><a href="#2-statement" class="headerlink" title="2.statement"></a>2.statement</h4><h5 id="a-解释：-1"><a href="#a-解释：-1" class="headerlink" title="a).解释："></a>a).解释：</h5><p>用于执行静态 SQL 语句并返回它所生成结果的对象。三种 Statement 类：</p><ul><li>Statement：由 createStatement 创建，用于发送简单的 SQL 语句（不带参数）。</li><li>PreparedStatement ：继承自 Statement 接口，由 preparedStatement 创建，用于发送含有一个或多个参数的 SQL 语句。PreparedStatement 对象比 Statement 对象的效率更高，并且可以防止 SQL 注入，所以我们一般都使用 PreparedStatement。</li><li>CallableStatement：继承自 PreparedStatement 接口，由方法 prepareCall 创建，用于调用存储过程。</li></ul><h5 id="b-常用方法：-1"><a href="#b-常用方法：-1" class="headerlink" title="b).常用方法："></a>b).常用方法：</h5><ul><li>execute(String sql):运行语句，返回是否有结果集</li><li>executeQuery(String sql)：运行 select 语句，返回 ResultSet 结果集。</li><li>executeUpdate(String sql)：运行 insert&#x2F;update&#x2F;delete 操作，返回更新的行数。</li><li>addBatch(String sql) ：把多条 sql 语句放到一个批处理中。</li><li>executeBatch()：向数据库发送一批 sql 语句执行。</li></ul><h2 id="五-Java-操作数据库实战"><a href="#五-Java-操作数据库实战" class="headerlink" title="五.Java 操作数据库实战"></a>五.Java 操作数据库实战</h2><h4 id="1-注册驱动"><a href="#1-注册驱动" class="headerlink" title="1.注册驱动"></a>1.注册驱动</h4><p>a).普通方式注册驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DriverManager.registerDriver(new com.mysql.jdbc.Driver);</span><br></pre></td></tr></table></figure><p>b).利用反射，用类加载器的方式注册驱动</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</span><br></pre></td></tr></table></figure><h4 id="2-建立-Java-与数据库的联系"><a href="#2-建立-Java-与数据库的联系" class="headerlink" title="2.建立 Java 与数据库的联系"></a>2.建立 Java 与数据库的联系</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/database&quot;, &quot;root&quot;, &quot;24694&quot;);</span><br></pre></td></tr></table></figure><p>第一个参数是固定写法，代表了你连接的是哪个数据库，这里是 MySQL<br><em>说明：jdbc:mysql 类似于网络协议 https，这是固定写法。而 port 代表端口号</em><br>第二个参数是数据库用户名<br>第三个参数是数据库密码</p><h4 id="3-获得可操作的数据库对象"><a href="#3-获得可操作的数据库对象" class="headerlink" title="3.获得可操作的数据库对象"></a>3.获得可操作的数据库对象</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stmt = conn.createStatement();</span><br></pre></td></tr></table></figure><h4 id="4-执行-SQL-语句"><a href="#4-执行-SQL-语句" class="headerlink" title="4.执行 SQL 语句"></a>4.执行 SQL 语句</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//执行SQL语句，会返回修改语句的条数，因为只涉及到一条操作，所以会返回1</span><br><span class="line">String sql = &quot;insert into test(age,name,local) values(50,&#x27;cofbro&#x27;,&#x27;China&#x27;)&quot;;</span><br><span class="line">int num = stmt.execute(sql);</span><br></pre></td></tr></table></figure><p>下面直接贴上完整代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public class DatabaseDemo &#123;</span><br><span class="line">    Connection conn = null;</span><br><span class="line">    Statement stmt = null;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            //注册驱动</span><br><span class="line">            DriverManager.registerDriver(new com.mysql.jdbc.Driver);</span><br><span class="line">            //建立JVM与数据库的连接</span><br><span class="line">            conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/database&quot;, &quot;root&quot;, &quot;24694&quot;);</span><br><span class="line">            //获取数据库操作对象</span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line">            //执行SQL语句，会返回修改语句的条数，因为只涉及到一条操作，所以会返回1</span><br><span class="line">            String sql = &quot;insert into test(age,name,local) values(50,&#x27;cofbro&#x27;,&#x27;China&#x27;)&quot;;</span><br><span class="line">            int num = stmt.execute(sql);</span><br><span class="line">            //查看是否修改成功</span><br><span class="line">            System.out.println(num == 1 ? &quot;保存成功&quot; : &quot;保存失败&quot;);</span><br><span class="line">        &#125; catch (SQLException e) &#123;</span><br><span class="line">            //若有异常，打印出异常信息</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            //释放资源</span><br><span class="line">            if (stnt != null) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    //先关小的，才能关上大的</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; catch (SQLException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                try &#123;</span><br><span class="line">                    if (conn != null)&#123;</span><br><span class="line">                        conn.close();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;catch (SQLException e)&#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android动态广播(android8.0)</title>
      <link href="/2022/05/07/Android%E5%8A%A8%E6%80%81%E5%B9%BF%E6%92%AD-android8-0/"/>
      <url>/2022/05/07/Android%E5%8A%A8%E6%80%81%E5%B9%BF%E6%92%AD-android8-0/</url>
      
        <content type="html"><![CDATA[<h2 id="Android-广播事件"><a href="#Android-广播事件" class="headerlink" title="Android 广播事件"></a>Android 广播事件</h2><h3 id="1-广播注册分类"><a href="#1-广播注册分类" class="headerlink" title="(1).广播注册分类"></a>(1).广播注册分类</h3><h4 id="a-动态注册-在-UI-中注册的广播，例如："><a href="#a-动态注册-在-UI-中注册的广播，例如：" class="headerlink" title="(a).动态注册 在 UI 中注册的广播，例如："></a>(a).动态注册 在 UI 中注册的广播，例如：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter intentFilter = new IntentFilter();</span><br><span class="line">//实现了Parcelable接口，可用于过滤广播</span><br><span class="line">intentFilter.addAction(Constants.ACTION_SEND_MSG);</span><br><span class="line">//设置过滤器，规定能接受的广播信号</span><br><span class="line">MessageReceiver messageReceiver = new MessageReceiver();</span><br><span class="line">this.registerReceiver(messageReceiver,intentFilter);</span><br><span class="line">//注册广播</span><br></pre></td></tr></table></figure><h4 id="b-静态注册"><a href="#b-静态注册" class="headerlink" title="(b).静态注册"></a>(b).静态注册</h4><p>需要在 manifest 中进行注册（在安卓 8.0 后系统废除了大部分静态广播，最好使用动态注册）。</p><h3 id="2-广播类型分类"><a href="#2-广播类型分类" class="headerlink" title="(2).广播类型分类"></a>(2).广播类型分类</h3><h4 id="a-系统广播"><a href="#a-系统广播" class="headerlink" title="(a).系统广播"></a>(a).系统广播</h4><p>系统中已经定义的广播，此类广播只能由系统发出，并且需要在 intent-filter 中加上系统已经写的 action。</p><h4 id="b-自定义广播"><a href="#b-自定义广播" class="headerlink" title="(b).自定义广播"></a>(b).自定义广播</h4><pre><code>顾名思义，是用户自己定义的广播。</code></pre><h3 id="3-动态实现广播"><a href="#3-动态实现广播" class="headerlink" title="(3).动态实现广播"></a>(3).动态实现广播</h3><h4 id="a-我们首先需要一个广播接收类"><a href="#a-我们首先需要一个广播接收类" class="headerlink" title="(a)我们首先需要一个广播接收类"></a>(a)我们首先需要一个广播接收类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public class MessageReceiver extends BroadcastReceiver&#123;</span><br><span class="line">        //新建一个自己的广播接受类继承自BroadcastReceiver</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void onReceive(Context context, Intent intent) &#123;</span><br><span class="line">            //重写onReceive方法，此方法写自己需要实现的逻辑</span><br><span class="line">            String detail = intent.getStringExtra(Constants.KEY_CONTENT);</span><br><span class="line">            Toast.makeText(SecondActivity.this, detail, Toast.LENGTH_SHORT).show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="a-其次注册动态广播"><a href="#a-其次注册动态广播" class="headerlink" title="(a)其次注册动态广播"></a>(a)其次注册动态广播</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MessageReceiver messageReceiver = new MessageReceiver();</span><br><span class="line">this.registerReceiver(messageReceiver,intentFilter);</span><br></pre></td></tr></table></figure><h4 id="c-最后需要通过-send-方法发送一个广播供广播接收者接受"><a href="#c-最后需要通过-send-方法发送一个广播供广播接收者接受" class="headerlink" title="(c)最后需要通过 send 方法发送一个广播供广播接收者接受"></a>(c)最后需要通过 send 方法发送一个广播供广播接收者接受</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public void send(View v)&#123;</span><br><span class="line">       String content = mInputBox.getText().toString();</span><br><span class="line">       //获取输入框中的值</span><br><span class="line">       Intent intent = new Intent();</span><br><span class="line">       intent.setAction(Constants.ACTION_SEND_MSG);</span><br><span class="line">       //设置action发送哪个广播，Constant类中书写的是常量</span><br><span class="line">       intent.putExtra(Constants.KEY_CONTENT,content);</span><br><span class="line">       //通过intent携带额外数据</span><br><span class="line">       sendBroadcast(intent);</span><br><span class="line">       //发送广播</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>整个过程完毕</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法练习：无重复字符的最长子串（滑动窗口）</title>
      <link href="/2022/05/07/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/"/>
      <url>/2022/05/07/%E7%AE%97%E6%B3%95%E7%BB%83%E4%B9%A0%EF%BC%9A%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2%EF%BC%88%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>今天遇到了这种找出无重复字符的最长子串的算法题，小编思来想去依旧没有想到有什么好方法，直到看到了大佬的算法，极为震撼，想写篇博客，记录下来。</p><p>题目如下：给出一组字符串，如 s &#x3D; “ adsjkhf ”，返回值为 7，s &#x3D; “abb”，返回值为 2，s &#x3D; “aab”，返回值为 2。请判断此字符串中无重复字符的最长子串。</p><h2 id="二-补充"><a href="#二-补充" class="headerlink" title="二.补充"></a>二.补充</h2><p>Java HashMap 中的方法：</p><p>get() 方法获取指定 key 对应对 value：map.get(key)</p><p>put() 方法将指定的键&#x2F;值对插入到 HashMap 中：map.put(key,value)</p><p>containsKey()方法如果 map 中存在指定的 key 对应的映射关系返回 true，否则返回 false。</p><h2 id="三-题解"><a href="#三-题解" class="headerlink" title="三.题解"></a>三.题解</h2><p>本题主要通过滑动窗口的思想解决。那么什么是滑动窗口呢？其实就是类似于两个前后指针，两个指针不断向后移，我们只关注指针中间的数，最后返回指针中间的元素的个数。</p><h4 id="1-分析"><a href="#1-分析" class="headerlink" title="(1) 分析"></a>(1) 分析</h4><p>我们先定义一个 map 容器用于存放字符串中的每个字符，然后从字符串的第一个字符 a 开始（ i &#x3D; 0 ）开始找，此时 map 里面是没有这个元素的，因此我们把 a 存放进 map 中，继续执行此操作直到出现 map 中有相同的字符，此时只需把 left 指针指向相同元素的后一位，两个指针中间的部分就是不重复字符的子串，此时这个子串的长度就为 i - left + 1。我们只需要用这个方法往后看去（随着 i 增加，即后指针向后指去），寻找是否有比当前子串长度更大的，若遇到则将现在的长度替换即可。</p><p>注意：字符串可能是这样的 –&gt; “ abbac”。按照我们的方法，会先将 ab 存入到我们的 map 当中，此时 left &#x3D; 0，当 i&#x3D;2 时，由于 map 中已经有 b，因此 left 将等于 get(b) + 1 &#x3D; 2。随后 i 指针向后指去又遇到 map 已有元素 a，按照前面的算法，此刻 left &#x3D; get(a) + 1 &#x3D; 1,但实际上 left 不会变，仍然等于 2，因此在求 left 值时总应该取最大的那个。</p><h4 id="2-代码详解"><a href="#2-代码详解" class="headerlink" title="(2) 代码详解"></a>(2) 代码详解</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line"></span><br><span class="line">       int maxLen = 0;//记录最长的的无重复字符串的长度</span><br><span class="line"></span><br><span class="line">        int left = 0;//前指针</span><br><span class="line"></span><br><span class="line">        HashMap&lt;Character,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        for (int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line"></span><br><span class="line">            if (map.containsKey(s.charAt(i)))&#123;    //若map中有此元素则执行下面代码</span><br><span class="line"></span><br><span class="line">                left = Math.max(left,map.get(s.charAt(i))+1);  //上面已经解释，此处应一直取较大的left</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            map.put(s.charAt(i),i);       //将s中的第i个元素存入map中</span><br><span class="line"></span><br><span class="line">            maxLen = Math.max(maxLen,i -left + 1);  //maxLen即为两个指针中间的元素个数</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return maxLen;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="3-图解"><a href="#3-图解" class="headerlink" title="(3) 图解"></a>(3) 图解</h4><p>最初 left&#x3D;0，i&#x3D;0，map 中无任何元素，此时 map 中将添加 a 字符</p><p>此时 i&#x3D;1，map 中将添加 b 字符</p><p>此时 i&#x3D;2，map 中将添加 c 字符</p><p>此时 i&#x3D;3，检测到 map 中已有 a，left 将指向到 map 中的 a 的后一位 b<br>以此类推遍历完字符串直到 i &#x3D; s.length()，返回最后的 maxLen 即为最终答案。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 算法练习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扑克比大小(Java&amp;Kotlin)</title>
      <link href="/2022/05/06/My-New-Post/"/>
      <url>/2022/05/06/My-New-Post/</url>
      
        <content type="html"><![CDATA[<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一.前言"></a>一.前言</h2><p>想要具备面向对象的思维，多写代码必不可少，今天记录的是一个能迅速使大家建立起面向对象思维的一个小 Demo<span id="more"></span>：从一副扑克中抽出 2 张牌来进行比较，具体如下：</p><div class="note success flat"><p><em>1.此副牌大小顺序为 2 &lt; 3 &lt; 4 &lt; 5 &lt; 6 &lt; 7 &lt; 8 &lt; 9 &lt; 10 &lt; J &lt; Q &lt; K &lt; A.</em><br><em>2.若点数相同则比较花色 ♠ &lt; ♥ &lt; ♣ &lt; ♦ .</em><br><em>注意：一副扑克中没有相同的两张牌.</em></p></div><h2 id="二-思考"><a href="#二-思考" class="headerlink" title="二.思考"></a>二.思考</h2><p>既然讲到面向对象的思维，那么在敲代码前一定要好好思考下比较两张扑克所包含的动作和事物有哪些？首先可以确定的是需要一副扑克，那么这固然是一类（Poker 类），只有有了扑克我们才能比大小，然而扑克就只是扑克吗，扑克中包含了哪些东西 ?点数和花色？那么这又是两类（PokerNumber 类和 PokerSuit 类），由于扑克牌是由点数和花色组成的，那么也就是说 PokerNumber 类和 PokerSuiit 类与 Poker 类是聚合关系。我们明白了扑克的组成，那么又是怎样将牌发出去从而比较大小的呢？这里就需要一个 PokerManager 来初始化扑克（我们的目的是实例化对象后就能将牌初始化，正好可以用构造方法）并将其发出去。</p><p>整个过程的 UML 图如下：<br><img src="https://upload-images.jianshu.io/upload_images/28033194-5c1753dbcb4edc77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="整个UML概览"></p><ul><li>简单介绍一下过程：我们是通过 PokerNumber 和 PokerSuit 来组成单一的扑克牌的，而这一张扑克是要被收到一起组成一副扑克，换句话说就是需要被 PokerManager 集中起来统一创建管理。在 PokerManager 中定义两个数组分别储存点数和花色。我们知道 PokerManager 中有很多 Poker，那 Poker 又是怎么来的呢，这就需要剩下的两个类组成它了：PokerNumber 和 PokerSuit。分别代表扑克点数和花色，这样一张扑克就诞生了。</li></ul><h4 id="1-创建-PokerNumber-类与-PokerSuit-类"><a href="#1-创建-PokerNumber-类与-PokerSuit-类" class="headerlink" title="1.创建 PokerNumber 类与 PokerSuit 类"></a>1.创建 PokerNumber 类与 PokerSuit 类</h4><p>为什么要创建这两类呢？是因为我们需要在创建花色和点数的时候就要为之后比大小做准备。我们一旦将点数和花色确定为字符串类型的时候，就无法通过 String 来比大小，只能再引入一个变量 tag（tag 为花色数组和点数数组的索引），通过 tag 来比较，因此要把这两个属性分装起来成为一个类。</p><h5 id="a-PokerNumber-类"><a href="#a-PokerNumber-类" class="headerlink" title="a).PokerNumber 类"></a>a).PokerNumber 类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class PokerNumber &#123;</span><br><span class="line">    private String number;</span><br><span class="line">    private int tag;</span><br><span class="line"></span><br><span class="line">    public PokerNumber(String number, int tag) &#123;</span><br><span class="line">        this.number = number;</span><br><span class="line">        this.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getNumber() &#123;</span><br><span class="line">        return number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setNumber(String number) &#123;</span><br><span class="line">        this.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getTag() &#123;</span><br><span class="line">        return tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTag(int tag) &#123;</span><br><span class="line">        this.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="b-PokerSuit-类"><a href="#b-PokerSuit-类" class="headerlink" title="b).PokerSuit 类"></a>b).PokerSuit 类</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class PokerSuit &#123;</span><br><span class="line">    private String suit;</span><br><span class="line">    private int tag;</span><br><span class="line"></span><br><span class="line">    public PokerSuit(String suit, int tag) &#123;</span><br><span class="line">        this.suit = suit;</span><br><span class="line">        this.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String getSuit() &#123;</span><br><span class="line">        return suit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setSuit(String suit) &#123;</span><br><span class="line">        this.suit = suit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int getTag() &#123;</span><br><span class="line">        return tag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setTag(int tag) &#123;</span><br><span class="line">        this.tag = tag;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-创建-Poker-类"><a href="#2-创建-Poker-类" class="headerlink" title="2.创建 Poker 类"></a>2.创建 Poker 类</h4><p>Poker 类中包含 PokerNumber 和 PokerSuit 属性。此外还应在此类写出比较扑克大小的方法并且重写 toString()方法修改 poker 输出格式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public class Poker &#123;</span><br><span class="line">    private PokerNumber pokerNumber;</span><br><span class="line">    private PokerSuit pokerSuit;</span><br><span class="line">    //初始化poker的两个属性 -&gt; 点数和花色</span><br><span class="line">    public Poker(PokerNumber pokerNumber, PokerSuit pokerSuit) &#123;</span><br><span class="line">        this.pokerNumber = pokerNumber;</span><br><span class="line">        this.pokerSuit = pokerSuit;</span><br><span class="line">    &#125;</span><br><span class="line">    //比较扑克牌大小</span><br><span class="line">    public boolean compareTo(Poker poker)&#123;</span><br><span class="line">        if (this.pokerNumber.getTag() == poker.pokerNumber.getTag())&#123;</span><br><span class="line">            //点数相同的情况下，若前者花色大与后者花色则返回true</span><br><span class="line">            return this.pokerSuit.getTag() &gt; poker.pokerSuit.getTag();</span><br><span class="line">        //点数大与后者，则返回true</span><br><span class="line">        &#125;else return this.pokerNumber.getTag() &gt; poker.pokerNumber.getTag();</span><br><span class="line">    &#125;</span><br><span class="line">     //重写toString() 格式化poker的输出格式</span><br><span class="line">    @Override</span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return</span><br><span class="line">                 pokerNumber.getNumber() +</span><br><span class="line">                 pokerSuit.getSuit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-创建-PokerManager-类"><a href="#3-创建-PokerManager-类" class="headerlink" title="3.创建 PokerManager 类"></a>3.创建 PokerManager 类</h4><p>PokerManager 类用于集中创建和管理扑克。并且我们要通过此类 getPoker 方法得到一张具体扑克。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class PokerManager &#123;</span><br><span class="line">    ArrayList&lt;Poker&gt; pokers = new ArrayList&lt;&gt;();//创建Poker类集合存放每一张扑克</span><br><span class="line">    public PokerManager()&#123;</span><br><span class="line">        String[] numbers = &#123;&quot;2&quot;, &quot;3&quot;, &quot;4&quot;, &quot;5&quot;, &quot;6&quot;, &quot;7&quot;, &quot;8&quot;, &quot;9&quot;, &quot;10&quot;, &quot;J&quot;, &quot;Q&quot;, &quot;K&quot;, &quot;A&quot;&#125;;</span><br><span class="line">        String[] suits = &#123;&quot;♦&quot;, &quot;♣&quot;, &quot;♥&quot;, &quot;♠&quot;&#125;;</span><br><span class="line">        for (int i = 0; i &lt; numbers.length; i++)&#123;</span><br><span class="line">            for (int j = 0; j&lt; suits.length; j++)&#123;</span><br><span class="line">                //通过两层for循环创建扑克，外层循环确定点数，内层循环确定花色</span><br><span class="line">                pokers.add(new Poker(new PokerNumber(numbers[i],i),new PokerSuit(suits[j],j)));</span><br><span class="line">                //将创建出来的扑克存进pokers集合里</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    //取出扑克的方法</span><br><span class="line">    public Poker getPoker()&#123;</span><br><span class="line">        Random r = new Random();</span><br><span class="line">        int index = r.nextInt(pokers.size());</span><br><span class="line">        //得到[0,pokers集合长度]大小的随机数</span><br><span class="line">        Poker poker = pokers.get(index);//拿到对应索引处的扑克</span><br><span class="line">        pokers.remove(index);//去重，已经拿到过的扑克牌应从这副牌中删去</span><br><span class="line">        return poker;//返回扑克对象</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-创建-Test-类，测试代码"><a href="#4-创建-Test-类，测试代码" class="headerlink" title="4.创建 Test 类，测试代码"></a>4.创建 Test 类，测试代码</h4><p>接下来就是运行代码，查看结果是否与预期相符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line"></span><br><span class="line">    private static Poker poker2;</span><br><span class="line">    private static Poker poker1;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        PokerManager pokerManager = new PokerManager();</span><br><span class="line">        //实例化对象，得到两张扑克牌</span><br><span class="line">        poker1 = pokerManager.getPoker();</span><br><span class="line">        poker2 = pokerManager.getPoker();</span><br><span class="line">        //调用compareTo方法判断大小，并输出判定结果</span><br><span class="line">        if (poker1.compareTo(poker2))&#123;</span><br><span class="line">            System.out.println(poker1 + &quot;&gt;&quot; + poker2);</span><br><span class="line">        &#125;else</span><br><span class="line">            System.out.println(poker1 + &quot;&lt;&quot; + poker2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-运行结果"><a href="#5-运行结果" class="headerlink" title="5.运行结果"></a>5.运行结果</h4><p><img src="https://upload-images.jianshu.io/upload_images/28033194-2822d9331ccc07e5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/28033194-b8bd69732e47bcdd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"><br><img src="https://upload-images.jianshu.io/upload_images/28033194-cd7f119357feecb3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240"></p><p>先记录到 Java…</p>]]></content>
      
      
      <categories>
          
          <category> Diary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
